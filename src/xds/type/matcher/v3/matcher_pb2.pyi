"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import typing
import typing_extensions
import xds.core.v3.extension_pb2
import xds.type.matcher.v3.string_pb2

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class Matcher(google.protobuf.message.Message):
    """[#protodoc-title: Unified Matcher API]

    A matcher, which may traverse a matching tree in order to result in a match action.
    During matching, the tree will be traversed until a match is found, or if no match
    is found the action specified by the most specific on_no_match will be evaluated.
    As an on_no_match might result in another matching tree being evaluated, this process
    might repeat several times until the final OnMatch (or no match) is decided.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class OnMatch(google.protobuf.message.Message):
        """What to do if a match is successful."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        MATCHER_FIELD_NUMBER: builtins.int
        ACTION_FIELD_NUMBER: builtins.int
        @property
        def matcher(self) -> global___Matcher:
            """Nested matcher to evaluate.
            If the nested matcher does not match and does not specify
            on_no_match, then this matcher is considered not to have
            matched, even if a predicate at this level or above returned
            true.
            """
            pass
        @property
        def action(self) -> xds.core.v3.extension_pb2.TypedExtensionConfig:
            """Protocol-specific action to take."""
            pass
        def __init__(self,
            *,
            matcher : typing.Optional[global___Matcher] = ...,
            action : typing.Optional[xds.core.v3.extension_pb2.TypedExtensionConfig] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"action",b"action",u"matcher",b"matcher",u"on_match",b"on_match"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"action",b"action",u"matcher",b"matcher",u"on_match",b"on_match"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal[u"on_match",b"on_match"]) -> typing.Optional[typing_extensions.Literal["matcher","action"]]: ...

    class MatcherList(google.protobuf.message.Message):
        """A linear list of field matchers.
        The field matchers are evaluated in order, and the first match
        wins.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class Predicate(google.protobuf.message.Message):
            """Predicate to determine if a match is successful."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            class SinglePredicate(google.protobuf.message.Message):
                """Predicate for a single input field."""
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                INPUT_FIELD_NUMBER: builtins.int
                VALUE_MATCH_FIELD_NUMBER: builtins.int
                CUSTOM_MATCH_FIELD_NUMBER: builtins.int
                @property
                def input(self) -> xds.core.v3.extension_pb2.TypedExtensionConfig:
                    """Protocol-specific specification of input field to match on.
                    [#extension-category: envoy.matching.common_inputs]
                    """
                    pass
                @property
                def value_match(self) -> xds.type.matcher.v3.string_pb2.StringMatcher:
                    """Built-in string matcher."""
                    pass
                @property
                def custom_match(self) -> xds.core.v3.extension_pb2.TypedExtensionConfig:
                    """Extension for custom matching logic.
                    [#extension-category: envoy.matching.input_matchers]
                    """
                    pass
                def __init__(self,
                    *,
                    input : typing.Optional[xds.core.v3.extension_pb2.TypedExtensionConfig] = ...,
                    value_match : typing.Optional[xds.type.matcher.v3.string_pb2.StringMatcher] = ...,
                    custom_match : typing.Optional[xds.core.v3.extension_pb2.TypedExtensionConfig] = ...,
                    ) -> None: ...
                def HasField(self, field_name: typing_extensions.Literal[u"custom_match",b"custom_match",u"input",b"input",u"matcher",b"matcher",u"value_match",b"value_match"]) -> builtins.bool: ...
                def ClearField(self, field_name: typing_extensions.Literal[u"custom_match",b"custom_match",u"input",b"input",u"matcher",b"matcher",u"value_match",b"value_match"]) -> None: ...
                def WhichOneof(self, oneof_group: typing_extensions.Literal[u"matcher",b"matcher"]) -> typing.Optional[typing_extensions.Literal["value_match","custom_match"]]: ...

            class PredicateList(google.protobuf.message.Message):
                """A list of two or more matchers. Used to allow using a list within a oneof."""
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                PREDICATE_FIELD_NUMBER: builtins.int
                @property
                def predicate(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Matcher.MatcherList.Predicate]: ...
                def __init__(self,
                    *,
                    predicate : typing.Optional[typing.Iterable[global___Matcher.MatcherList.Predicate]] = ...,
                    ) -> None: ...
                def ClearField(self, field_name: typing_extensions.Literal[u"predicate",b"predicate"]) -> None: ...

            SINGLE_PREDICATE_FIELD_NUMBER: builtins.int
            OR_MATCHER_FIELD_NUMBER: builtins.int
            AND_MATCHER_FIELD_NUMBER: builtins.int
            NOT_MATCHER_FIELD_NUMBER: builtins.int
            @property
            def single_predicate(self) -> global___Matcher.MatcherList.Predicate.SinglePredicate:
                """A single predicate to evaluate."""
                pass
            @property
            def or_matcher(self) -> global___Matcher.MatcherList.Predicate.PredicateList:
                """A list of predicates to be OR-ed together."""
                pass
            @property
            def and_matcher(self) -> global___Matcher.MatcherList.Predicate.PredicateList:
                """A list of predicates to be AND-ed together."""
                pass
            @property
            def not_matcher(self) -> global___Matcher.MatcherList.Predicate:
                """The invert of a predicate"""
                pass
            def __init__(self,
                *,
                single_predicate : typing.Optional[global___Matcher.MatcherList.Predicate.SinglePredicate] = ...,
                or_matcher : typing.Optional[global___Matcher.MatcherList.Predicate.PredicateList] = ...,
                and_matcher : typing.Optional[global___Matcher.MatcherList.Predicate.PredicateList] = ...,
                not_matcher : typing.Optional[global___Matcher.MatcherList.Predicate] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal[u"and_matcher",b"and_matcher",u"match_type",b"match_type",u"not_matcher",b"not_matcher",u"or_matcher",b"or_matcher",u"single_predicate",b"single_predicate"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal[u"and_matcher",b"and_matcher",u"match_type",b"match_type",u"not_matcher",b"not_matcher",u"or_matcher",b"or_matcher",u"single_predicate",b"single_predicate"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal[u"match_type",b"match_type"]) -> typing.Optional[typing_extensions.Literal["single_predicate","or_matcher","and_matcher","not_matcher"]]: ...

        class FieldMatcher(google.protobuf.message.Message):
            """An individual matcher."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            PREDICATE_FIELD_NUMBER: builtins.int
            ON_MATCH_FIELD_NUMBER: builtins.int
            @property
            def predicate(self) -> global___Matcher.MatcherList.Predicate:
                """Determines if the match succeeds."""
                pass
            @property
            def on_match(self) -> global___Matcher.OnMatch:
                """What to do if the match succeeds."""
                pass
            def __init__(self,
                *,
                predicate : typing.Optional[global___Matcher.MatcherList.Predicate] = ...,
                on_match : typing.Optional[global___Matcher.OnMatch] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal[u"on_match",b"on_match",u"predicate",b"predicate"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal[u"on_match",b"on_match",u"predicate",b"predicate"]) -> None: ...

        MATCHERS_FIELD_NUMBER: builtins.int
        @property
        def matchers(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Matcher.MatcherList.FieldMatcher]:
            """A list of matchers. First match wins."""
            pass
        def __init__(self,
            *,
            matchers : typing.Optional[typing.Iterable[global___Matcher.MatcherList.FieldMatcher]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"matchers",b"matchers"]) -> None: ...

    class MatcherTree(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class MatchMap(google.protobuf.message.Message):
            """A map of configured matchers. Used to allow using a map within a oneof."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            class MapEntry(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                KEY_FIELD_NUMBER: builtins.int
                VALUE_FIELD_NUMBER: builtins.int
                key: typing.Text = ...
                @property
                def value(self) -> global___Matcher.OnMatch: ...
                def __init__(self,
                    *,
                    key : typing.Text = ...,
                    value : typing.Optional[global___Matcher.OnMatch] = ...,
                    ) -> None: ...
                def HasField(self, field_name: typing_extensions.Literal[u"value",b"value"]) -> builtins.bool: ...
                def ClearField(self, field_name: typing_extensions.Literal[u"key",b"key",u"value",b"value"]) -> None: ...

            MAP_FIELD_NUMBER: builtins.int
            @property
            def map(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, global___Matcher.OnMatch]: ...
            def __init__(self,
                *,
                map : typing.Optional[typing.Mapping[typing.Text, global___Matcher.OnMatch]] = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal[u"map",b"map"]) -> None: ...

        INPUT_FIELD_NUMBER: builtins.int
        EXACT_MATCH_MAP_FIELD_NUMBER: builtins.int
        PREFIX_MATCH_MAP_FIELD_NUMBER: builtins.int
        CUSTOM_MATCH_FIELD_NUMBER: builtins.int
        @property
        def input(self) -> xds.core.v3.extension_pb2.TypedExtensionConfig:
            """Protocol-specific specification of input field to match on."""
            pass
        @property
        def exact_match_map(self) -> global___Matcher.MatcherTree.MatchMap: ...
        @property
        def prefix_match_map(self) -> global___Matcher.MatcherTree.MatchMap:
            """Longest matching prefix wins."""
            pass
        @property
        def custom_match(self) -> xds.core.v3.extension_pb2.TypedExtensionConfig:
            """Extension for custom matching logic."""
            pass
        def __init__(self,
            *,
            input : typing.Optional[xds.core.v3.extension_pb2.TypedExtensionConfig] = ...,
            exact_match_map : typing.Optional[global___Matcher.MatcherTree.MatchMap] = ...,
            prefix_match_map : typing.Optional[global___Matcher.MatcherTree.MatchMap] = ...,
            custom_match : typing.Optional[xds.core.v3.extension_pb2.TypedExtensionConfig] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"custom_match",b"custom_match",u"exact_match_map",b"exact_match_map",u"input",b"input",u"prefix_match_map",b"prefix_match_map",u"tree_type",b"tree_type"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"custom_match",b"custom_match",u"exact_match_map",b"exact_match_map",u"input",b"input",u"prefix_match_map",b"prefix_match_map",u"tree_type",b"tree_type"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal[u"tree_type",b"tree_type"]) -> typing.Optional[typing_extensions.Literal["exact_match_map","prefix_match_map","custom_match"]]: ...

    MATCHER_LIST_FIELD_NUMBER: builtins.int
    MATCHER_TREE_FIELD_NUMBER: builtins.int
    ON_NO_MATCH_FIELD_NUMBER: builtins.int
    @property
    def matcher_list(self) -> global___Matcher.MatcherList:
        """A linear list of matchers to evaluate."""
        pass
    @property
    def matcher_tree(self) -> global___Matcher.MatcherTree:
        """A match tree to evaluate."""
        pass
    @property
    def on_no_match(self) -> global___Matcher.OnMatch:
        """Optional OnMatch to use if no matcher above matched (e.g., if there are no matchers specified
        above, or if none of the matches specified above succeeded).
        If no matcher above matched and this field is not populated, the match will be considered unsuccessful.
        """
        pass
    def __init__(self,
        *,
        matcher_list : typing.Optional[global___Matcher.MatcherList] = ...,
        matcher_tree : typing.Optional[global___Matcher.MatcherTree] = ...,
        on_no_match : typing.Optional[global___Matcher.OnMatch] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"matcher_list",b"matcher_list",u"matcher_tree",b"matcher_tree",u"matcher_type",b"matcher_type",u"on_no_match",b"on_no_match"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"matcher_list",b"matcher_list",u"matcher_tree",b"matcher_tree",u"matcher_type",b"matcher_type",u"on_no_match",b"on_no_match"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"matcher_type",b"matcher_type"]) -> typing.Optional[typing_extensions.Literal["matcher_list","matcher_tree"]]: ...
global___Matcher = Matcher
