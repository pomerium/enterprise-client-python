"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import envoy.type.matcher.v4alpha.value_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class MetadataMatcher(google.protobuf.message.Message):
    """[#protodoc-title: Metadata matcher]

    MetadataMatcher provides a general interface to check if a given value is matched in
    :ref:`Metadata <envoy_v3_api_msg_config.core.v3.Metadata>`. It uses `filter` and `path` to retrieve the value
    from the Metadata and then check if it's matched to the specified value.

    For example, for the following Metadata:

    .. code-block:: yaml

       filter_metadata:
         envoy.filters.http.rbac:
           fields:
             a:
               struct_value:
                 fields:
                   b:
                     struct_value:
                       fields:
                         c:
                           string_value: pro
                   t:
                     list_value:
                       values:
                         - string_value: m
                         - string_value: n

    The following MetadataMatcher is matched as the path [a, b, c] will retrieve a string value "pro"
    from the Metadata which is matched to the specified prefix match.

    .. code-block:: yaml

       filter: envoy.filters.http.rbac
       path:
       - key: a
       - key: b
       - key: c
       value:
         string_match:
           prefix: pr

    The following MetadataMatcher is matched as the code will match one of the string values in the
    list at the path [a, t].

    .. code-block:: yaml

       filter: envoy.filters.http.rbac
       path:
       - key: a
       - key: t
       value:
         list_match:
           one_of:
             string_match:
               exact: m

    An example use of MetadataMatcher is specifying additional metadata in envoy.filters.http.rbac to
    enforce access control based on dynamic metadata in a request. See :ref:`Permission
    <envoy_v3_api_msg_config.rbac.v3.Permission>` and :ref:`Principal
    <envoy_v3_api_msg_config.rbac.v3.Principal>`.

    [#next-major-version: MetadataMatcher should use StructMatcher]
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class PathSegment(google.protobuf.message.Message):
        """Specifies the segment in a path to retrieve value from Metadata.
        Note: Currently it's not supported to retrieve a value from a list in Metadata. This means that
        if the segment key refers to a list, it has to be the last segment in a path.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        """If specified, use the key to retrieve the value in a Struct."""

        def __init__(self,
            *,
            key : typing.Text = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"key",b"key",u"segment",b"segment"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"key",b"key",u"segment",b"segment"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal[u"segment",b"segment"]) -> typing.Optional[typing_extensions.Literal["key"]]: ...

    FILTER_FIELD_NUMBER: builtins.int
    PATH_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    filter: typing.Text = ...
    """The filter name to retrieve the Struct from the Metadata."""

    @property
    def path(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___MetadataMatcher.PathSegment]:
        """The path to retrieve the Value from the Struct."""
        pass
    @property
    def value(self) -> envoy.type.matcher.v4alpha.value_pb2.ValueMatcher:
        """The MetadataMatcher is matched if the value retrieved by path is matched to this value."""
        pass
    def __init__(self,
        *,
        filter : typing.Text = ...,
        path : typing.Optional[typing.Iterable[global___MetadataMatcher.PathSegment]] = ...,
        value : typing.Optional[envoy.type.matcher.v4alpha.value_pb2.ValueMatcher] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"value",b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"filter",b"filter",u"path",b"path",u"value",b"value"]) -> None: ...
global___MetadataMatcher = MetadataMatcher
