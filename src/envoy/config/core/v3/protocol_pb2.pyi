"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import envoy.config.core.v3.extension_pb2
import envoy.type.v3.percent_pb2
import google.protobuf.descriptor
import google.protobuf.duration_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.wrappers_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class TcpProtocolOptions(google.protobuf.message.Message):
    """[#protodoc-title: Protocol options]

    [#not-implemented-hide:]
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___TcpProtocolOptions = TcpProtocolOptions

class QuicProtocolOptions(google.protobuf.message.Message):
    """QUIC protocol options which apply to both downstream and upstream connections."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    MAX_CONCURRENT_STREAMS_FIELD_NUMBER: builtins.int
    INITIAL_STREAM_WINDOW_SIZE_FIELD_NUMBER: builtins.int
    INITIAL_CONNECTION_WINDOW_SIZE_FIELD_NUMBER: builtins.int
    @property
    def max_concurrent_streams(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """Maximum number of streams that the client can negotiate per connection. 100
        if not specified.
        """
        pass
    @property
    def initial_stream_window_size(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """`Initial stream-level flow-control receive window
        <https://tools.ietf.org/html/draft-ietf-quic-transport-34#section-4.1>`_ size. Valid values range from
        1 to 16777216 (2^24, maximum supported by QUICHE) and defaults to 65536 (2^16).

        NOTE: 16384 (2^14) is the minimum window size supported in Google QUIC. If configured smaller than it, we will use 16384 instead.
        QUICHE IETF Quic implementation supports 1 bytes window. We only support increasing the default window size now, so it's also the minimum.

        This field also acts as a soft limit on the number of bytes Envoy will buffer per-stream in the
        QUIC stream send and receive buffers. Once the buffer reaches this pointer, watermark callbacks will fire to
        stop the flow of data to the stream buffers.
        """
        pass
    @property
    def initial_connection_window_size(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """Similar to *initial_stream_window_size*, but for connection-level
        flow-control. Valid values rage from 1 to 25165824 (24MB, maximum supported by QUICHE) and defaults to 65536 (2^16).
        window. Currently, this has the same minimum/default as *initial_stream_window_size*.

        NOTE: 16384 (2^14) is the minimum window size supported in Google QUIC. We only support increasing the default
        window size now, so it's also the minimum.
        """
        pass
    def __init__(self,
        *,
        max_concurrent_streams : typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        initial_stream_window_size : typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        initial_connection_window_size : typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"initial_connection_window_size",b"initial_connection_window_size",u"initial_stream_window_size",b"initial_stream_window_size",u"max_concurrent_streams",b"max_concurrent_streams"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"initial_connection_window_size",b"initial_connection_window_size",u"initial_stream_window_size",b"initial_stream_window_size",u"max_concurrent_streams",b"max_concurrent_streams"]) -> None: ...
global___QuicProtocolOptions = QuicProtocolOptions

class UpstreamHttpProtocolOptions(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    AUTO_SNI_FIELD_NUMBER: builtins.int
    AUTO_SAN_VALIDATION_FIELD_NUMBER: builtins.int
    auto_sni: builtins.bool = ...
    """Set transport socket `SNI <https://en.wikipedia.org/wiki/Server_Name_Indication>`_ for new
    upstream connections based on the downstream HTTP host/authority header, as seen by the
    :ref:`router filter <config_http_filters_router>`.
    """

    auto_san_validation: builtins.bool = ...
    """Automatic validate upstream presented certificate for new upstream connections based on the
    downstream HTTP host/authority header, as seen by the
    :ref:`router filter <config_http_filters_router>`.
    This field is intended to set with `auto_sni` field.
    """

    def __init__(self,
        *,
        auto_sni : builtins.bool = ...,
        auto_san_validation : builtins.bool = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"auto_san_validation",b"auto_san_validation",u"auto_sni",b"auto_sni"]) -> None: ...
global___UpstreamHttpProtocolOptions = UpstreamHttpProtocolOptions

class AlternateProtocolsCacheOptions(google.protobuf.message.Message):
    """Configures the alternate protocols cache which tracks alternate protocols that can be used to
    make an HTTP connection to an origin server. See https://tools.ietf.org/html/rfc7838 for
    HTTP Alternative Services and https://datatracker.ietf.org/doc/html/draft-ietf-dnsop-svcb-https-04
    for the "HTTPS" DNS resource record.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    MAX_ENTRIES_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """The name of the cache. Multiple named caches allow independent alternate protocols cache
    configurations to operate within a single Envoy process using different configurations. All
    alternate protocols cache options with the same name *must* be equal in all fields when
    referenced from different configuration components. Configuration will fail to load if this is
    not the case.
    """

    @property
    def max_entries(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """The maximum number of entries that the cache will hold. If not specified defaults to 1024.

        .. note:

          The implementation is approximate and enforced independently on each worker thread, thus
          it is possible for the maximum entries in the cache to go slightly above the configured
          value depending on timing. This is similar to how other circuit breakers work.
        """
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        max_entries : typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"max_entries",b"max_entries"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"max_entries",b"max_entries",u"name",b"name"]) -> None: ...
global___AlternateProtocolsCacheOptions = AlternateProtocolsCacheOptions

class HttpProtocolOptions(google.protobuf.message.Message):
    """[#next-free-field: 7]"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class HeadersWithUnderscoresAction(_HeadersWithUnderscoresAction, metaclass=_HeadersWithUnderscoresActionEnumTypeWrapper):
        """Action to take when Envoy receives client request with header names containing underscore
        characters.
        Underscore character is allowed in header names by the RFC-7230 and this behavior is implemented
        as a security measure due to systems that treat '_' and '-' as interchangeable. Envoy by default allows client request headers with underscore
        characters.
        """
        pass
    class _HeadersWithUnderscoresAction:
        V = typing.NewType('V', builtins.int)
    class _HeadersWithUnderscoresActionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_HeadersWithUnderscoresAction.V], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        ALLOW = HttpProtocolOptions.HeadersWithUnderscoresAction.V(0)
        """Allow headers with underscores. This is the default behavior."""

        REJECT_REQUEST = HttpProtocolOptions.HeadersWithUnderscoresAction.V(1)
        """Reject client request. HTTP/1 requests are rejected with the 400 status. HTTP/2 requests
        end with the stream reset. The "httpN.requests_rejected_with_underscores_in_headers" counter
        is incremented for each rejected request.
        """

        DROP_HEADER = HttpProtocolOptions.HeadersWithUnderscoresAction.V(2)
        """Drop the header with name containing underscores. The header is dropped before the filter chain is
        invoked and as such filters will not see dropped headers. The
        "httpN.dropped_headers_with_underscores" is incremented for each dropped header.
        """


    ALLOW = HttpProtocolOptions.HeadersWithUnderscoresAction.V(0)
    """Allow headers with underscores. This is the default behavior."""

    REJECT_REQUEST = HttpProtocolOptions.HeadersWithUnderscoresAction.V(1)
    """Reject client request. HTTP/1 requests are rejected with the 400 status. HTTP/2 requests
    end with the stream reset. The "httpN.requests_rejected_with_underscores_in_headers" counter
    is incremented for each rejected request.
    """

    DROP_HEADER = HttpProtocolOptions.HeadersWithUnderscoresAction.V(2)
    """Drop the header with name containing underscores. The header is dropped before the filter chain is
    invoked and as such filters will not see dropped headers. The
    "httpN.dropped_headers_with_underscores" is incremented for each dropped header.
    """


    IDLE_TIMEOUT_FIELD_NUMBER: builtins.int
    MAX_CONNECTION_DURATION_FIELD_NUMBER: builtins.int
    MAX_HEADERS_COUNT_FIELD_NUMBER: builtins.int
    MAX_STREAM_DURATION_FIELD_NUMBER: builtins.int
    HEADERS_WITH_UNDERSCORES_ACTION_FIELD_NUMBER: builtins.int
    MAX_REQUESTS_PER_CONNECTION_FIELD_NUMBER: builtins.int
    @property
    def idle_timeout(self) -> google.protobuf.duration_pb2.Duration:
        """The idle timeout for connections. The idle timeout is defined as the
        period in which there are no active requests. When the
        idle timeout is reached the connection will be closed. If the connection is an HTTP/2
        downstream connection a drain sequence will occur prior to closing the connection, see
        :ref:`drain_timeout
        <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.drain_timeout>`.
        Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive.
        If not specified, this defaults to 1 hour. To disable idle timeouts explicitly set this to 0.

        .. warning::
          Disabling this timeout has a highly likelihood of yielding connection leaks due to lost TCP
          FIN packets, etc.

        If the :ref:`overload action <config_overload_manager_overload_actions>` "envoy.overload_actions.reduce_timeouts"
        is configured, this timeout is scaled for downstream connections according to the value for
        :ref:`HTTP_DOWNSTREAM_CONNECTION_IDLE <envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_CONNECTION_IDLE>`.
        """
        pass
    @property
    def max_connection_duration(self) -> google.protobuf.duration_pb2.Duration:
        """The maximum duration of a connection. The duration is defined as a period since a connection
        was established. If not set, there is no max duration. When max_connection_duration is reached
        the connection will be closed. Drain sequence will occur prior to closing the connection if
        if's applicable. See :ref:`drain_timeout
        <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.drain_timeout>`.
        Note: not implemented for upstream connections.
        """
        pass
    @property
    def max_headers_count(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """The maximum number of headers. If unconfigured, the default
        maximum number of request headers allowed is 100. Requests that exceed this limit will receive
        a 431 response for HTTP/1.x and cause a stream reset for HTTP/2.
        """
        pass
    @property
    def max_stream_duration(self) -> google.protobuf.duration_pb2.Duration:
        """Total duration to keep alive an HTTP request/response stream. If the time limit is reached the stream will be
        reset independent of any other timeouts. If not specified, this value is not set.
        """
        pass
    headers_with_underscores_action: global___HttpProtocolOptions.HeadersWithUnderscoresAction.V = ...
    """Action to take when a client request with a header name containing underscore characters is received.
    If this setting is not specified, the value defaults to ALLOW.
    Note: upstream responses are not affected by this setting.
    """

    @property
    def max_requests_per_connection(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """Optional maximum requests for both upstream and downstream connections.
        If not specified, there is no limit.
        Setting this parameter to 1 will effectively disable keep alive.
        For HTTP/2 and HTTP/3, due to concurrent stream processing, the limit is approximate.
        """
        pass
    def __init__(self,
        *,
        idle_timeout : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        max_connection_duration : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        max_headers_count : typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        max_stream_duration : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        headers_with_underscores_action : global___HttpProtocolOptions.HeadersWithUnderscoresAction.V = ...,
        max_requests_per_connection : typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"idle_timeout",b"idle_timeout",u"max_connection_duration",b"max_connection_duration",u"max_headers_count",b"max_headers_count",u"max_requests_per_connection",b"max_requests_per_connection",u"max_stream_duration",b"max_stream_duration"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"headers_with_underscores_action",b"headers_with_underscores_action",u"idle_timeout",b"idle_timeout",u"max_connection_duration",b"max_connection_duration",u"max_headers_count",b"max_headers_count",u"max_requests_per_connection",b"max_requests_per_connection",u"max_stream_duration",b"max_stream_duration"]) -> None: ...
global___HttpProtocolOptions = HttpProtocolOptions

class Http1ProtocolOptions(google.protobuf.message.Message):
    """[#next-free-field: 8]"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class HeaderKeyFormat(google.protobuf.message.Message):
        """[#next-free-field: 9]"""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class ProperCaseWords(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            def __init__(self,
                ) -> None: ...

        PROPER_CASE_WORDS_FIELD_NUMBER: builtins.int
        STATEFUL_FORMATTER_FIELD_NUMBER: builtins.int
        @property
        def proper_case_words(self) -> global___Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords:
            """Formats the header by proper casing words: the first character and any character following
            a special character will be capitalized if it's an alpha character. For example,
            "content-type" becomes "Content-Type", and "foo$b#$are" becomes "Foo$B#$Are".
            Note that while this results in most headers following conventional casing, certain headers
            are not covered. For example, the "TE" header will be formatted as "Te".
            """
            pass
        @property
        def stateful_formatter(self) -> envoy.config.core.v3.extension_pb2.TypedExtensionConfig:
            """Configuration for stateful formatter extensions that allow using received headers to
            affect the output of encoding headers. E.g., preserving case during proxying.
            [#extension-category: envoy.http.stateful_header_formatters]
            """
            pass
        def __init__(self,
            *,
            proper_case_words : typing.Optional[global___Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords] = ...,
            stateful_formatter : typing.Optional[envoy.config.core.v3.extension_pb2.TypedExtensionConfig] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"header_format",b"header_format",u"proper_case_words",b"proper_case_words",u"stateful_formatter",b"stateful_formatter"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"header_format",b"header_format",u"proper_case_words",b"proper_case_words",u"stateful_formatter",b"stateful_formatter"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal[u"header_format",b"header_format"]) -> typing.Optional[typing_extensions.Literal["proper_case_words","stateful_formatter"]]: ...

    ALLOW_ABSOLUTE_URL_FIELD_NUMBER: builtins.int
    ACCEPT_HTTP_10_FIELD_NUMBER: builtins.int
    DEFAULT_HOST_FOR_HTTP_10_FIELD_NUMBER: builtins.int
    HEADER_KEY_FORMAT_FIELD_NUMBER: builtins.int
    ENABLE_TRAILERS_FIELD_NUMBER: builtins.int
    ALLOW_CHUNKED_LENGTH_FIELD_NUMBER: builtins.int
    OVERRIDE_STREAM_ERROR_ON_INVALID_HTTP_MESSAGE_FIELD_NUMBER: builtins.int
    @property
    def allow_absolute_url(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """Handle HTTP requests with absolute URLs in the requests. These requests
        are generally sent by clients to forward/explicit proxies. This allows clients to configure
        envoy as their HTTP proxy. In Unix, for example, this is typically done by setting the
        *http_proxy* environment variable.
        """
        pass
    accept_http_10: builtins.bool = ...
    """Handle incoming HTTP/1.0 and HTTP 0.9 requests.
    This is off by default, and not fully standards compliant. There is support for pre-HTTP/1.1
    style connect logic, dechunking, and handling lack of client host iff
    *default_host_for_http_10* is configured.
    """

    default_host_for_http_10: typing.Text = ...
    """A default host for HTTP/1.0 requests. This is highly suggested if *accept_http_10* is true as
    Envoy does not otherwise support HTTP/1.0 without a Host header.
    This is a no-op if *accept_http_10* is not true.
    """

    @property
    def header_key_format(self) -> global___Http1ProtocolOptions.HeaderKeyFormat:
        """Describes how the keys for response headers should be formatted. By default, all header keys
        are lower cased.
        """
        pass
    enable_trailers: builtins.bool = ...
    """Enables trailers for HTTP/1. By default the HTTP/1 codec drops proxied trailers.

    .. attention::

      Note that this only happens when Envoy is chunk encoding which occurs when:
      - The request is HTTP/1.1.
      - Is neither a HEAD only request nor a HTTP Upgrade.
      - Not a response to a HEAD request.
      - The content length header is not present.
    """

    allow_chunked_length: builtins.bool = ...
    """Allows Envoy to process requests/responses with both `Content-Length` and `Transfer-Encoding`
    headers set. By default such messages are rejected, but if option is enabled - Envoy will
    remove Content-Length header and process message.
    See `RFC7230, sec. 3.3.3 <https://tools.ietf.org/html/rfc7230#section-3.3.3>` for details.

    .. attention::
      Enabling this option might lead to request smuggling vulnerability, especially if traffic
      is proxied via multiple layers of proxies.
    """

    @property
    def override_stream_error_on_invalid_http_message(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """Allows invalid HTTP messaging. When this option is false, then Envoy will terminate
        HTTP/1.1 connections upon receiving an invalid HTTP message. However,
        when this option is true, then Envoy will leave the HTTP/1.1 connection
        open where possible.
        If set, this overrides any HCM :ref:`stream_error_on_invalid_http_messaging
        <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message>`.
        """
        pass
    def __init__(self,
        *,
        allow_absolute_url : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
        accept_http_10 : builtins.bool = ...,
        default_host_for_http_10 : typing.Text = ...,
        header_key_format : typing.Optional[global___Http1ProtocolOptions.HeaderKeyFormat] = ...,
        enable_trailers : builtins.bool = ...,
        allow_chunked_length : builtins.bool = ...,
        override_stream_error_on_invalid_http_message : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"allow_absolute_url",b"allow_absolute_url",u"header_key_format",b"header_key_format",u"override_stream_error_on_invalid_http_message",b"override_stream_error_on_invalid_http_message"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"accept_http_10",b"accept_http_10",u"allow_absolute_url",b"allow_absolute_url",u"allow_chunked_length",b"allow_chunked_length",u"default_host_for_http_10",b"default_host_for_http_10",u"enable_trailers",b"enable_trailers",u"header_key_format",b"header_key_format",u"override_stream_error_on_invalid_http_message",b"override_stream_error_on_invalid_http_message"]) -> None: ...
global___Http1ProtocolOptions = Http1ProtocolOptions

class KeepaliveSettings(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    INTERVAL_FIELD_NUMBER: builtins.int
    TIMEOUT_FIELD_NUMBER: builtins.int
    INTERVAL_JITTER_FIELD_NUMBER: builtins.int
    CONNECTION_IDLE_INTERVAL_FIELD_NUMBER: builtins.int
    @property
    def interval(self) -> google.protobuf.duration_pb2.Duration:
        """Send HTTP/2 PING frames at this period, in order to test that the connection is still alive.
        If this is zero, interval PINGs will not be sent.
        """
        pass
    @property
    def timeout(self) -> google.protobuf.duration_pb2.Duration:
        """How long to wait for a response to a keepalive PING. If a response is not received within this
        time period, the connection will be aborted.
        """
        pass
    @property
    def interval_jitter(self) -> envoy.type.v3.percent_pb2.Percent:
        """A random jitter amount as a percentage of interval that will be added to each interval.
        A value of zero means there will be no jitter.
        The default value is 15%.
        """
        pass
    @property
    def connection_idle_interval(self) -> google.protobuf.duration_pb2.Duration:
        """If the connection has been idle for this duration, send a HTTP/2 ping ahead
        of new stream creation, to quickly detect dead connections.
        If this is zero, this type of PING will not be sent.
        If an interval ping is outstanding, a second ping will not be sent as the
        interval ping will determine if the connection is dead.
        """
        pass
    def __init__(self,
        *,
        interval : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        timeout : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        interval_jitter : typing.Optional[envoy.type.v3.percent_pb2.Percent] = ...,
        connection_idle_interval : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"connection_idle_interval",b"connection_idle_interval",u"interval",b"interval",u"interval_jitter",b"interval_jitter",u"timeout",b"timeout"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"connection_idle_interval",b"connection_idle_interval",u"interval",b"interval",u"interval_jitter",b"interval_jitter",u"timeout",b"timeout"]) -> None: ...
global___KeepaliveSettings = KeepaliveSettings

class Http2ProtocolOptions(google.protobuf.message.Message):
    """[#next-free-field: 16]"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class SettingsParameter(google.protobuf.message.Message):
        """Defines a parameter to be sent in the SETTINGS frame.
        See `RFC7540, sec. 6.5.1 <https://tools.ietf.org/html/rfc7540#section-6.5.1>`_ for details.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        IDENTIFIER_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        @property
        def identifier(self) -> google.protobuf.wrappers_pb2.UInt32Value:
            """The 16 bit parameter identifier."""
            pass
        @property
        def value(self) -> google.protobuf.wrappers_pb2.UInt32Value:
            """The 32 bit parameter value."""
            pass
        def __init__(self,
            *,
            identifier : typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
            value : typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"identifier",b"identifier",u"value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"identifier",b"identifier",u"value",b"value"]) -> None: ...

    HPACK_TABLE_SIZE_FIELD_NUMBER: builtins.int
    MAX_CONCURRENT_STREAMS_FIELD_NUMBER: builtins.int
    INITIAL_STREAM_WINDOW_SIZE_FIELD_NUMBER: builtins.int
    INITIAL_CONNECTION_WINDOW_SIZE_FIELD_NUMBER: builtins.int
    ALLOW_CONNECT_FIELD_NUMBER: builtins.int
    ALLOW_METADATA_FIELD_NUMBER: builtins.int
    MAX_OUTBOUND_FRAMES_FIELD_NUMBER: builtins.int
    MAX_OUTBOUND_CONTROL_FRAMES_FIELD_NUMBER: builtins.int
    MAX_CONSECUTIVE_INBOUND_FRAMES_WITH_EMPTY_PAYLOAD_FIELD_NUMBER: builtins.int
    MAX_INBOUND_PRIORITY_FRAMES_PER_STREAM_FIELD_NUMBER: builtins.int
    MAX_INBOUND_WINDOW_UPDATE_FRAMES_PER_DATA_FRAME_SENT_FIELD_NUMBER: builtins.int
    STREAM_ERROR_ON_INVALID_HTTP_MESSAGING_FIELD_NUMBER: builtins.int
    OVERRIDE_STREAM_ERROR_ON_INVALID_HTTP_MESSAGE_FIELD_NUMBER: builtins.int
    CUSTOM_SETTINGS_PARAMETERS_FIELD_NUMBER: builtins.int
    CONNECTION_KEEPALIVE_FIELD_NUMBER: builtins.int
    @property
    def hpack_table_size(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """`Maximum table size <https://httpwg.org/specs/rfc7541.html#rfc.section.4.2>`_
        (in octets) that the encoder is permitted to use for the dynamic HPACK table. Valid values
        range from 0 to 4294967295 (2^32 - 1) and defaults to 4096. 0 effectively disables header
        compression.
        """
        pass
    @property
    def max_concurrent_streams(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """`Maximum concurrent streams <https://httpwg.org/specs/rfc7540.html#rfc.section.5.1.2>`_
        allowed for peer on one HTTP/2 connection. Valid values range from 1 to 2147483647 (2^31 - 1)
        and defaults to 2147483647.

        For upstream connections, this also limits how many streams Envoy will initiate concurrently
        on a single connection. If the limit is reached, Envoy may queue requests or establish
        additional connections (as allowed per circuit breaker limits).

        This acts as an upper bound: Envoy will lower the max concurrent streams allowed on a given
        connection based on upstream settings. Config dumps will reflect the configured upper bound,
        not the per-connection negotiated limits.
        """
        pass
    @property
    def initial_stream_window_size(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """`Initial stream-level flow-control window
        <https://httpwg.org/specs/rfc7540.html#rfc.section.6.9.2>`_ size. Valid values range from 65535
        (2^16 - 1, HTTP/2 default) to 2147483647 (2^31 - 1, HTTP/2 maximum) and defaults to 268435456
        (256 * 1024 * 1024).

        NOTE: 65535 is the initial window size from HTTP/2 spec. We only support increasing the default
        window size now, so it's also the minimum.

        This field also acts as a soft limit on the number of bytes Envoy will buffer per-stream in the
        HTTP/2 codec buffers. Once the buffer reaches this pointer, watermark callbacks will fire to
        stop the flow of data to the codec buffers.
        """
        pass
    @property
    def initial_connection_window_size(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """Similar to *initial_stream_window_size*, but for connection-level flow-control
        window. Currently, this has the same minimum/maximum/default as *initial_stream_window_size*.
        """
        pass
    allow_connect: builtins.bool = ...
    """Allows proxying Websocket and other upgrades over H2 connect."""

    allow_metadata: builtins.bool = ...
    """[#not-implemented-hide:] Hiding until envoy has full metadata support.
    Still under implementation. DO NOT USE.

    Allows metadata. See [metadata
    docs](https://github.com/envoyproxy/envoy/blob/main/source/docs/h2_metadata.md) for more
    information.
    """

    @property
    def max_outbound_frames(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """Limit the number of pending outbound downstream frames of all types (frames that are waiting to
        be written into the socket). Exceeding this limit triggers flood mitigation and connection is
        terminated. The ``http2.outbound_flood`` stat tracks the number of terminated connections due
        to flood mitigation. The default limit is 10000.
        NOTE: flood and abuse mitigation for upstream connections is presently enabled by the
        `envoy.reloadable_features.upstream_http2_flood_checks` flag.
        """
        pass
    @property
    def max_outbound_control_frames(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """Limit the number of pending outbound downstream frames of types PING, SETTINGS and RST_STREAM,
        preventing high memory utilization when receiving continuous stream of these frames. Exceeding
        this limit triggers flood mitigation and connection is terminated. The
        ``http2.outbound_control_flood`` stat tracks the number of terminated connections due to flood
        mitigation. The default limit is 1000.
        NOTE: flood and abuse mitigation for upstream connections is presently enabled by the
        `envoy.reloadable_features.upstream_http2_flood_checks` flag.
        """
        pass
    @property
    def max_consecutive_inbound_frames_with_empty_payload(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """Limit the number of consecutive inbound frames of types HEADERS, CONTINUATION and DATA with an
        empty payload and no end stream flag. Those frames have no legitimate use and are abusive, but
        might be a result of a broken HTTP/2 implementation. The `http2.inbound_empty_frames_flood``
        stat tracks the number of connections terminated due to flood mitigation.
        Setting this to 0 will terminate connection upon receiving first frame with an empty payload
        and no end stream flag. The default limit is 1.
        NOTE: flood and abuse mitigation for upstream connections is presently enabled by the
        `envoy.reloadable_features.upstream_http2_flood_checks` flag.
        """
        pass
    @property
    def max_inbound_priority_frames_per_stream(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """Limit the number of inbound PRIORITY frames allowed per each opened stream. If the number
        of PRIORITY frames received over the lifetime of connection exceeds the value calculated
        using this formula::

          max_inbound_priority_frames_per_stream * (1 + opened_streams)

        the connection is terminated. For downstream connections the `opened_streams` is incremented when
        Envoy receives complete response headers from the upstream server. For upstream connection the
        `opened_streams` is incremented when Envoy send the HEADERS frame for a new stream. The
        ``http2.inbound_priority_frames_flood`` stat tracks
        the number of connections terminated due to flood mitigation. The default limit is 100.
        NOTE: flood and abuse mitigation for upstream connections is presently enabled by the
        `envoy.reloadable_features.upstream_http2_flood_checks` flag.
        """
        pass
    @property
    def max_inbound_window_update_frames_per_data_frame_sent(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """Limit the number of inbound WINDOW_UPDATE frames allowed per DATA frame sent. If the number
        of WINDOW_UPDATE frames received over the lifetime of connection exceeds the value calculated
        using this formula::

          5 + 2 * (opened_streams +
                   max_inbound_window_update_frames_per_data_frame_sent * outbound_data_frames)

        the connection is terminated. For downstream connections the `opened_streams` is incremented when
        Envoy receives complete response headers from the upstream server. For upstream connections the
        `opened_streams` is incremented when Envoy sends the HEADERS frame for a new stream. The
        ``http2.inbound_priority_frames_flood`` stat tracks the number of connections terminated due to
        flood mitigation. The default max_inbound_window_update_frames_per_data_frame_sent value is 10.
        Setting this to 1 should be enough to support HTTP/2 implementations with basic flow control,
        but more complex implementations that try to estimate available bandwidth require at least 2.
        NOTE: flood and abuse mitigation for upstream connections is presently enabled by the
        `envoy.reloadable_features.upstream_http2_flood_checks` flag.
        """
        pass
    stream_error_on_invalid_http_messaging: builtins.bool = ...
    """Allows invalid HTTP messaging and headers. When this option is disabled (default), then
    the whole HTTP/2 connection is terminated upon receiving invalid HEADERS frame. However,
    when this option is enabled, only the offending stream is terminated.

    This is overridden by HCM :ref:`stream_error_on_invalid_http_messaging
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message>`
    iff present.

    This is deprecated in favor of :ref:`override_stream_error_on_invalid_http_message
    <envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message>`

    See `RFC7540, sec. 8.1 <https://tools.ietf.org/html/rfc7540#section-8.1>`_ for details.
    """

    @property
    def override_stream_error_on_invalid_http_message(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """Allows invalid HTTP messaging and headers. When this option is disabled (default), then
        the whole HTTP/2 connection is terminated upon receiving invalid HEADERS frame. However,
        when this option is enabled, only the offending stream is terminated.

        This overrides any HCM :ref:`stream_error_on_invalid_http_messaging
        <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message>`

        See `RFC7540, sec. 8.1 <https://tools.ietf.org/html/rfc7540#section-8.1>`_ for details.
        """
        pass
    @property
    def custom_settings_parameters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Http2ProtocolOptions.SettingsParameter]:
        """[#not-implemented-hide:]
        Specifies SETTINGS frame parameters to be sent to the peer, with two exceptions:

        1. SETTINGS_ENABLE_PUSH (0x2) is not configurable as HTTP/2 server push is not supported by
        Envoy.

        2. SETTINGS_ENABLE_CONNECT_PROTOCOL (0x8) is only configurable through the named field
        'allow_connect'.

        Note that custom parameters specified through this field can not also be set in the
        corresponding named parameters:

        .. code-block:: text

          ID    Field Name
          ----------------
          0x1   hpack_table_size
          0x3   max_concurrent_streams
          0x4   initial_stream_window_size

        Collisions will trigger config validation failure on load/update. Likewise, inconsistencies
        between custom parameters with the same identifier will trigger a failure.

        See `IANA HTTP/2 Settings
        <https://www.iana.org/assignments/http2-parameters/http2-parameters.xhtml#settings>`_ for
        standardized identifiers.
        """
        pass
    @property
    def connection_keepalive(self) -> global___KeepaliveSettings:
        """Send HTTP/2 PING frames to verify that the connection is still healthy. If the remote peer
        does not respond within the configured timeout, the connection will be aborted.
        """
        pass
    def __init__(self,
        *,
        hpack_table_size : typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        max_concurrent_streams : typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        initial_stream_window_size : typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        initial_connection_window_size : typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        allow_connect : builtins.bool = ...,
        allow_metadata : builtins.bool = ...,
        max_outbound_frames : typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        max_outbound_control_frames : typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        max_consecutive_inbound_frames_with_empty_payload : typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        max_inbound_priority_frames_per_stream : typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        max_inbound_window_update_frames_per_data_frame_sent : typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        stream_error_on_invalid_http_messaging : builtins.bool = ...,
        override_stream_error_on_invalid_http_message : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
        custom_settings_parameters : typing.Optional[typing.Iterable[global___Http2ProtocolOptions.SettingsParameter]] = ...,
        connection_keepalive : typing.Optional[global___KeepaliveSettings] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"connection_keepalive",b"connection_keepalive",u"hpack_table_size",b"hpack_table_size",u"initial_connection_window_size",b"initial_connection_window_size",u"initial_stream_window_size",b"initial_stream_window_size",u"max_concurrent_streams",b"max_concurrent_streams",u"max_consecutive_inbound_frames_with_empty_payload",b"max_consecutive_inbound_frames_with_empty_payload",u"max_inbound_priority_frames_per_stream",b"max_inbound_priority_frames_per_stream",u"max_inbound_window_update_frames_per_data_frame_sent",b"max_inbound_window_update_frames_per_data_frame_sent",u"max_outbound_control_frames",b"max_outbound_control_frames",u"max_outbound_frames",b"max_outbound_frames",u"override_stream_error_on_invalid_http_message",b"override_stream_error_on_invalid_http_message"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"allow_connect",b"allow_connect",u"allow_metadata",b"allow_metadata",u"connection_keepalive",b"connection_keepalive",u"custom_settings_parameters",b"custom_settings_parameters",u"hpack_table_size",b"hpack_table_size",u"initial_connection_window_size",b"initial_connection_window_size",u"initial_stream_window_size",b"initial_stream_window_size",u"max_concurrent_streams",b"max_concurrent_streams",u"max_consecutive_inbound_frames_with_empty_payload",b"max_consecutive_inbound_frames_with_empty_payload",u"max_inbound_priority_frames_per_stream",b"max_inbound_priority_frames_per_stream",u"max_inbound_window_update_frames_per_data_frame_sent",b"max_inbound_window_update_frames_per_data_frame_sent",u"max_outbound_control_frames",b"max_outbound_control_frames",u"max_outbound_frames",b"max_outbound_frames",u"override_stream_error_on_invalid_http_message",b"override_stream_error_on_invalid_http_message",u"stream_error_on_invalid_http_messaging",b"stream_error_on_invalid_http_messaging"]) -> None: ...
global___Http2ProtocolOptions = Http2ProtocolOptions

class GrpcProtocolOptions(google.protobuf.message.Message):
    """[#not-implemented-hide:]"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    HTTP2_PROTOCOL_OPTIONS_FIELD_NUMBER: builtins.int
    @property
    def http2_protocol_options(self) -> global___Http2ProtocolOptions: ...
    def __init__(self,
        *,
        http2_protocol_options : typing.Optional[global___Http2ProtocolOptions] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"http2_protocol_options",b"http2_protocol_options"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"http2_protocol_options",b"http2_protocol_options"]) -> None: ...
global___GrpcProtocolOptions = GrpcProtocolOptions

class Http3ProtocolOptions(google.protobuf.message.Message):
    """A message which allows using HTTP/3."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    QUIC_PROTOCOL_OPTIONS_FIELD_NUMBER: builtins.int
    OVERRIDE_STREAM_ERROR_ON_INVALID_HTTP_MESSAGE_FIELD_NUMBER: builtins.int
    @property
    def quic_protocol_options(self) -> global___QuicProtocolOptions: ...
    @property
    def override_stream_error_on_invalid_http_message(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """Allows invalid HTTP messaging and headers. When this option is disabled (default), then
        the whole HTTP/3 connection is terminated upon receiving invalid HEADERS frame. However,
        when this option is enabled, only the offending stream is terminated.

        If set, this overrides any HCM :ref:`stream_error_on_invalid_http_messaging
        <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message>`.
        """
        pass
    def __init__(self,
        *,
        quic_protocol_options : typing.Optional[global___QuicProtocolOptions] = ...,
        override_stream_error_on_invalid_http_message : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"override_stream_error_on_invalid_http_message",b"override_stream_error_on_invalid_http_message",u"quic_protocol_options",b"quic_protocol_options"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"override_stream_error_on_invalid_http_message",b"override_stream_error_on_invalid_http_message",u"quic_protocol_options",b"quic_protocol_options"]) -> None: ...
global___Http3ProtocolOptions = Http3ProtocolOptions

class SchemeHeaderTransformation(google.protobuf.message.Message):
    """A message to control transformations to the :scheme header"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SCHEME_TO_OVERWRITE_FIELD_NUMBER: builtins.int
    scheme_to_overwrite: typing.Text = ...
    """Overwrite any Scheme header with the contents of this string."""

    def __init__(self,
        *,
        scheme_to_overwrite : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"scheme_to_overwrite",b"scheme_to_overwrite",u"transformation",b"transformation"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"scheme_to_overwrite",b"scheme_to_overwrite",u"transformation",b"transformation"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"transformation",b"transformation"]) -> typing.Optional[typing_extensions.Literal["scheme_to_overwrite"]]: ...
global___SchemeHeaderTransformation = SchemeHeaderTransformation
