"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import envoy.config.route.v3.route_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class ScopedRouteConfiguration(google.protobuf.message.Message):
    """[#protodoc-title: HTTP scoped routing configuration]
    * Routing :ref:`architecture overview <arch_overview_http_routing>`

    Specifies a routing scope, which associates a
    :ref:`Key<envoy_v3_api_msg_config.route.v3.ScopedRouteConfiguration.Key>` to a
    :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`.
    The :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration` can be obtained dynamically
    via RDS (:ref:`route_configuration_name<envoy_v3_api_field_config.route.v3.ScopedRouteConfiguration.route_configuration_name>`)
    or specified inline (:ref:`route_configuration<envoy_v3_api_field_config.route.v3.ScopedRouteConfiguration.route_configuration>`).

    The HTTP connection manager builds up a table consisting of these Key to
    RouteConfiguration mappings, and looks up the RouteConfiguration to use per
    request according to the algorithm specified in the
    :ref:`scope_key_builder<envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.ScopedRoutes.scope_key_builder>`
    assigned to the HttpConnectionManager.

    For example, with the following configurations (in YAML):

    HttpConnectionManager config:

    .. code::

      ...
      scoped_routes:
        name: foo-scoped-routes
        scope_key_builder:
          fragments:
            - header_value_extractor:
                name: X-Route-Selector
                element_separator: ,
                element:
                  separator: =
                  key: vip

    ScopedRouteConfiguration resources (specified statically via
    :ref:`scoped_route_configurations_list<envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.ScopedRoutes.scoped_route_configurations_list>`
    or obtained dynamically via SRDS):

    .. code::

     (1)
      name: route-scope1
      route_configuration_name: route-config1
      key:
         fragments:
           - string_key: 172.10.10.20

     (2)
      name: route-scope2
      route_configuration_name: route-config2
      key:
        fragments:
          - string_key: 172.20.20.30

    A request from a client such as:

    .. code::

        GET / HTTP/1.1
        Host: foo.com
        X-Route-Selector: vip=172.10.10.20

    would result in the routing table defined by the `route-config1`
    RouteConfiguration being assigned to the HTTP request/stream.

    [#next-free-field: 6]
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Key(google.protobuf.message.Message):
        """Specifies a key which is matched against the output of the
        :ref:`scope_key_builder<envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.ScopedRoutes.scope_key_builder>`
        specified in the HttpConnectionManager. The matching is done per HTTP
        request and is dependent on the order of the fragments contained in the
        Key.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class Fragment(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            STRING_KEY_FIELD_NUMBER: builtins.int
            string_key: typing.Text = ...
            """A string to match against."""

            def __init__(self,
                *,
                string_key : typing.Text = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal[u"string_key",b"string_key",u"type",b"type"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal[u"string_key",b"string_key",u"type",b"type"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal[u"type",b"type"]) -> typing.Optional[typing_extensions.Literal["string_key"]]: ...

        FRAGMENTS_FIELD_NUMBER: builtins.int
        @property
        def fragments(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ScopedRouteConfiguration.Key.Fragment]:
            """The ordered set of fragments to match against. The order must match the
            fragments in the corresponding
            :ref:`scope_key_builder<envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.ScopedRoutes.scope_key_builder>`.
            """
            pass
        def __init__(self,
            *,
            fragments : typing.Optional[typing.Iterable[global___ScopedRouteConfiguration.Key.Fragment]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"fragments",b"fragments"]) -> None: ...

    ON_DEMAND_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    ROUTE_CONFIGURATION_NAME_FIELD_NUMBER: builtins.int
    ROUTE_CONFIGURATION_FIELD_NUMBER: builtins.int
    KEY_FIELD_NUMBER: builtins.int
    on_demand: builtins.bool = ...
    """Whether the RouteConfiguration should be loaded on demand."""

    name: typing.Text = ...
    """The name assigned to the routing scope."""

    route_configuration_name: typing.Text = ...
    """The resource name to use for a :ref:`envoy_v3_api_msg_service.discovery.v3.DiscoveryRequest` to an
    RDS server to fetch the :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration` associated
    with this scope.
    """

    @property
    def route_configuration(self) -> envoy.config.route.v3.route_pb2.RouteConfiguration:
        """The :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration` associated with the scope."""
        pass
    @property
    def key(self) -> global___ScopedRouteConfiguration.Key:
        """The key to match against."""
        pass
    def __init__(self,
        *,
        on_demand : builtins.bool = ...,
        name : typing.Text = ...,
        route_configuration_name : typing.Text = ...,
        route_configuration : typing.Optional[envoy.config.route.v3.route_pb2.RouteConfiguration] = ...,
        key : typing.Optional[global___ScopedRouteConfiguration.Key] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"key",b"key",u"route_configuration",b"route_configuration"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"key",b"key",u"name",b"name",u"on_demand",b"on_demand",u"route_configuration",b"route_configuration",u"route_configuration_name",b"route_configuration_name"]) -> None: ...
global___ScopedRouteConfiguration = ScopedRouteConfiguration
