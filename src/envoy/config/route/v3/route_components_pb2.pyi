"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import envoy.config.core.v3.base_pb2
import envoy.config.core.v3.extension_pb2
import envoy.config.core.v3.proxy_protocol_pb2
import envoy.type.matcher.v3.regex_pb2
import envoy.type.matcher.v3.string_pb2
import envoy.type.metadata.v3.metadata_pb2
import envoy.type.tracing.v3.custom_tag_pb2
import envoy.type.v3.percent_pb2
import envoy.type.v3.range_pb2
import google.protobuf.any_pb2
import google.protobuf.descriptor
import google.protobuf.duration_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.wrappers_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class VirtualHost(google.protobuf.message.Message):
    """[#protodoc-title: HTTP route components]
    * Routing :ref:`architecture overview <arch_overview_http_routing>`
    * HTTP :ref:`router filter <config_http_filters_router>`

    The top level element in the routing configuration is a virtual host. Each virtual host has
    a logical name as well as a set of domains that get routed to it based on the incoming request's
    host header. This allows a single listener to service multiple top level domain path trees. Once
    a virtual host is selected based on the domain, the routes are processed in order to see which
    upstream cluster to route to or whether to perform a redirect.
    [#next-free-field: 21]
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class TlsRequirementType(_TlsRequirementType, metaclass=_TlsRequirementTypeEnumTypeWrapper):
        pass
    class _TlsRequirementType:
        V = typing.NewType('V', builtins.int)
    class _TlsRequirementTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_TlsRequirementType.V], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        NONE = VirtualHost.TlsRequirementType.V(0)
        """No TLS requirement for the virtual host."""

        EXTERNAL_ONLY = VirtualHost.TlsRequirementType.V(1)
        """External requests must use TLS. If a request is external and it is not
        using TLS, a 301 redirect will be sent telling the client to use HTTPS.
        """

        ALL = VirtualHost.TlsRequirementType.V(2)
        """All requests must use TLS. If a request is not using TLS, a 301 redirect
        will be sent telling the client to use HTTPS.
        """


    NONE = VirtualHost.TlsRequirementType.V(0)
    """No TLS requirement for the virtual host."""

    EXTERNAL_ONLY = VirtualHost.TlsRequirementType.V(1)
    """External requests must use TLS. If a request is external and it is not
    using TLS, a 301 redirect will be sent telling the client to use HTTPS.
    """

    ALL = VirtualHost.TlsRequirementType.V(2)
    """All requests must use TLS. If a request is not using TLS, a 301 redirect
    will be sent telling the client to use HTTPS.
    """


    class TypedPerFilterConfigEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        @property
        def value(self) -> google.protobuf.any_pb2.Any: ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Optional[google.protobuf.any_pb2.Any] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"key",b"key",u"value",b"value"]) -> None: ...

    NAME_FIELD_NUMBER: builtins.int
    DOMAINS_FIELD_NUMBER: builtins.int
    ROUTES_FIELD_NUMBER: builtins.int
    REQUIRE_TLS_FIELD_NUMBER: builtins.int
    VIRTUAL_CLUSTERS_FIELD_NUMBER: builtins.int
    RATE_LIMITS_FIELD_NUMBER: builtins.int
    REQUEST_HEADERS_TO_ADD_FIELD_NUMBER: builtins.int
    REQUEST_HEADERS_TO_REMOVE_FIELD_NUMBER: builtins.int
    RESPONSE_HEADERS_TO_ADD_FIELD_NUMBER: builtins.int
    RESPONSE_HEADERS_TO_REMOVE_FIELD_NUMBER: builtins.int
    CORS_FIELD_NUMBER: builtins.int
    TYPED_PER_FILTER_CONFIG_FIELD_NUMBER: builtins.int
    INCLUDE_REQUEST_ATTEMPT_COUNT_FIELD_NUMBER: builtins.int
    INCLUDE_ATTEMPT_COUNT_IN_RESPONSE_FIELD_NUMBER: builtins.int
    RETRY_POLICY_FIELD_NUMBER: builtins.int
    RETRY_POLICY_TYPED_CONFIG_FIELD_NUMBER: builtins.int
    HEDGE_POLICY_FIELD_NUMBER: builtins.int
    PER_REQUEST_BUFFER_LIMIT_BYTES_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """The logical name of the virtual host. This is used when emitting certain
    statistics but is not relevant for routing.
    """

    @property
    def domains(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """A list of domains (host/authority header) that will be matched to this
        virtual host. Wildcard hosts are supported in the suffix or prefix form.

        Domain search order:
         1. Exact domain names: ``www.foo.com``.
         2. Suffix domain wildcards: ``*.foo.com`` or ``*-bar.foo.com``.
         3. Prefix domain wildcards: ``foo.*`` or ``foo-*``.
         4. Special wildcard ``*`` matching any domain.

        .. note::

          The wildcard will not match the empty string.
          e.g. ``*-bar.foo.com`` will match ``baz-bar.foo.com`` but not ``-bar.foo.com``.
          The longest wildcards match first.
          Only a single virtual host in the entire route configuration can match on ``*``. A domain
          must be unique across all virtual hosts or the config will fail to load.

        Domains cannot contain control characters. This is validated by the well_known_regex HTTP_HEADER_VALUE.
        """
        pass
    @property
    def routes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Route]:
        """The list of routes that will be matched, in order, for incoming requests.
        The first route that matches will be used.
        """
        pass
    require_tls: global___VirtualHost.TlsRequirementType.V = ...
    """Specifies the type of TLS enforcement the virtual host expects. If this option is not
    specified, there is no TLS requirement for the virtual host.
    """

    @property
    def virtual_clusters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___VirtualCluster]:
        """A list of virtual clusters defined for this virtual host. Virtual clusters
        are used for additional statistics gathering.
        """
        pass
    @property
    def rate_limits(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RateLimit]:
        """Specifies a set of rate limit configurations that will be applied to the
        virtual host.
        """
        pass
    @property
    def request_headers_to_add(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[envoy.config.core.v3.base_pb2.HeaderValueOption]:
        """Specifies a list of HTTP headers that should be added to each request
        handled by this virtual host. Headers specified at this level are applied
        after headers from enclosed :ref:`envoy_v3_api_msg_config.route.v3.Route` and before headers from the
        enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including
        details on header value syntax, see the documentation on :ref:`custom request headers
        <config_http_conn_man_headers_custom_request_headers>`.
        """
        pass
    @property
    def request_headers_to_remove(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Specifies a list of HTTP headers that should be removed from each request
        handled by this virtual host.
        """
        pass
    @property
    def response_headers_to_add(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[envoy.config.core.v3.base_pb2.HeaderValueOption]:
        """Specifies a list of HTTP headers that should be added to each response
        handled by this virtual host. Headers specified at this level are applied
        after headers from enclosed :ref:`envoy_v3_api_msg_config.route.v3.Route` and before headers from the
        enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including
        details on header value syntax, see the documentation on :ref:`custom request headers
        <config_http_conn_man_headers_custom_request_headers>`.
        """
        pass
    @property
    def response_headers_to_remove(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Specifies a list of HTTP headers that should be removed from each response
        handled by this virtual host.
        """
        pass
    @property
    def cors(self) -> global___CorsPolicy:
        """Indicates that the virtual host has a CORS policy."""
        pass
    @property
    def typed_per_filter_config(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, google.protobuf.any_pb2.Any]:
        """The per_filter_config field can be used to provide virtual host-specific
        configurations for filters. The key should match the filter name, such as
        *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter
        specific; see the :ref:`HTTP filter documentation <config_http_filters>`
        for if and how it is utilized.
        [#comment: An entry's value may be wrapped in a
        :ref:`FilterConfig<envoy_v3_api_msg_config.route.v3.FilterConfig>`
        message to specify additional options.]
        """
        pass
    include_request_attempt_count: builtins.bool = ...
    """Decides whether the :ref:`x-envoy-attempt-count
    <config_http_filters_router_x-envoy-attempt-count>` header should be included
    in the upstream request. Setting this option will cause it to override any existing header
    value, so in the case of two Envoys on the request path with this option enabled, the upstream
    will see the attempt count as perceived by the second Envoy. Defaults to false.
    This header is unaffected by the
    :ref:`suppress_envoy_headers
    <envoy_v3_api_field_extensions.filters.http.router.v3.Router.suppress_envoy_headers>` flag.

    [#next-major-version: rename to include_attempt_count_in_request.]
    """

    include_attempt_count_in_response: builtins.bool = ...
    """Decides whether the :ref:`x-envoy-attempt-count
    <config_http_filters_router_x-envoy-attempt-count>` header should be included
    in the downstream response. Setting this option will cause the router to override any existing header
    value, so in the case of two Envoys on the request path with this option enabled, the downstream
    will see the attempt count as perceived by the Envoy closest upstream from itself. Defaults to false.
    This header is unaffected by the
    :ref:`suppress_envoy_headers
    <envoy_v3_api_field_extensions.filters.http.router.v3.Router.suppress_envoy_headers>` flag.
    """

    @property
    def retry_policy(self) -> global___RetryPolicy:
        """Indicates the retry policy for all routes in this virtual host. Note that setting a
        route level entry will take precedence over this config and it'll be treated
        independently (e.g.: values are not inherited).
        """
        pass
    @property
    def retry_policy_typed_config(self) -> google.protobuf.any_pb2.Any:
        """[#not-implemented-hide:]
        Specifies the configuration for retry policy extension. Note that setting a route level entry
        will take precedence over this config and it'll be treated independently (e.g.: values are not
        inherited). :ref:`Retry policy <envoy_v3_api_field_config.route.v3.VirtualHost.retry_policy>` should not be
        set if this field is used.
        """
        pass
    @property
    def hedge_policy(self) -> global___HedgePolicy:
        """Indicates the hedge policy for all routes in this virtual host. Note that setting a
        route level entry will take precedence over this config and it'll be treated
        independently (e.g.: values are not inherited).
        """
        pass
    @property
    def per_request_buffer_limit_bytes(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """The maximum bytes which will be buffered for retries and shadowing.
        If set and a route-specific limit is not set, the bytes actually buffered will be the minimum
        value of this and the listener per_connection_buffer_limit_bytes.
        """
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        domains : typing.Optional[typing.Iterable[typing.Text]] = ...,
        routes : typing.Optional[typing.Iterable[global___Route]] = ...,
        require_tls : global___VirtualHost.TlsRequirementType.V = ...,
        virtual_clusters : typing.Optional[typing.Iterable[global___VirtualCluster]] = ...,
        rate_limits : typing.Optional[typing.Iterable[global___RateLimit]] = ...,
        request_headers_to_add : typing.Optional[typing.Iterable[envoy.config.core.v3.base_pb2.HeaderValueOption]] = ...,
        request_headers_to_remove : typing.Optional[typing.Iterable[typing.Text]] = ...,
        response_headers_to_add : typing.Optional[typing.Iterable[envoy.config.core.v3.base_pb2.HeaderValueOption]] = ...,
        response_headers_to_remove : typing.Optional[typing.Iterable[typing.Text]] = ...,
        cors : typing.Optional[global___CorsPolicy] = ...,
        typed_per_filter_config : typing.Optional[typing.Mapping[typing.Text, google.protobuf.any_pb2.Any]] = ...,
        include_request_attempt_count : builtins.bool = ...,
        include_attempt_count_in_response : builtins.bool = ...,
        retry_policy : typing.Optional[global___RetryPolicy] = ...,
        retry_policy_typed_config : typing.Optional[google.protobuf.any_pb2.Any] = ...,
        hedge_policy : typing.Optional[global___HedgePolicy] = ...,
        per_request_buffer_limit_bytes : typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"cors",b"cors",u"hedge_policy",b"hedge_policy",u"per_request_buffer_limit_bytes",b"per_request_buffer_limit_bytes",u"retry_policy",b"retry_policy",u"retry_policy_typed_config",b"retry_policy_typed_config"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"cors",b"cors",u"domains",b"domains",u"hedge_policy",b"hedge_policy",u"include_attempt_count_in_response",b"include_attempt_count_in_response",u"include_request_attempt_count",b"include_request_attempt_count",u"name",b"name",u"per_request_buffer_limit_bytes",b"per_request_buffer_limit_bytes",u"rate_limits",b"rate_limits",u"request_headers_to_add",b"request_headers_to_add",u"request_headers_to_remove",b"request_headers_to_remove",u"require_tls",b"require_tls",u"response_headers_to_add",b"response_headers_to_add",u"response_headers_to_remove",b"response_headers_to_remove",u"retry_policy",b"retry_policy",u"retry_policy_typed_config",b"retry_policy_typed_config",u"routes",b"routes",u"typed_per_filter_config",b"typed_per_filter_config",u"virtual_clusters",b"virtual_clusters"]) -> None: ...
global___VirtualHost = VirtualHost

class FilterAction(google.protobuf.message.Message):
    """A filter-defined action type."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ACTION_FIELD_NUMBER: builtins.int
    @property
    def action(self) -> google.protobuf.any_pb2.Any: ...
    def __init__(self,
        *,
        action : typing.Optional[google.protobuf.any_pb2.Any] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"action",b"action"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"action",b"action"]) -> None: ...
global___FilterAction = FilterAction

class Route(google.protobuf.message.Message):
    """A route is both a specification of how to match a request as well as an indication of what to do
    next (e.g., redirect, forward, rewrite, etc.).

    .. attention::

      Envoy supports routing on HTTP method via :ref:`header matching
      <envoy_v3_api_msg_config.route.v3.HeaderMatcher>`.
    [#next-free-field: 19]
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class TypedPerFilterConfigEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        @property
        def value(self) -> google.protobuf.any_pb2.Any: ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Optional[google.protobuf.any_pb2.Any] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"key",b"key",u"value",b"value"]) -> None: ...

    NAME_FIELD_NUMBER: builtins.int
    MATCH_FIELD_NUMBER: builtins.int
    ROUTE_FIELD_NUMBER: builtins.int
    REDIRECT_FIELD_NUMBER: builtins.int
    DIRECT_RESPONSE_FIELD_NUMBER: builtins.int
    FILTER_ACTION_FIELD_NUMBER: builtins.int
    NON_FORWARDING_ACTION_FIELD_NUMBER: builtins.int
    METADATA_FIELD_NUMBER: builtins.int
    DECORATOR_FIELD_NUMBER: builtins.int
    TYPED_PER_FILTER_CONFIG_FIELD_NUMBER: builtins.int
    REQUEST_HEADERS_TO_ADD_FIELD_NUMBER: builtins.int
    REQUEST_HEADERS_TO_REMOVE_FIELD_NUMBER: builtins.int
    RESPONSE_HEADERS_TO_ADD_FIELD_NUMBER: builtins.int
    RESPONSE_HEADERS_TO_REMOVE_FIELD_NUMBER: builtins.int
    TRACING_FIELD_NUMBER: builtins.int
    PER_REQUEST_BUFFER_LIMIT_BYTES_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Name for the route."""

    @property
    def match(self) -> global___RouteMatch:
        """Route matching parameters."""
        pass
    @property
    def route(self) -> global___RouteAction:
        """Route request to some upstream cluster."""
        pass
    @property
    def redirect(self) -> global___RedirectAction:
        """Return a redirect."""
        pass
    @property
    def direct_response(self) -> global___DirectResponseAction:
        """Return an arbitrary HTTP response directly, without proxying."""
        pass
    @property
    def filter_action(self) -> global___FilterAction:
        """[#not-implemented-hide:]
        A filter-defined action (e.g., it could dynamically generate the RouteAction).
        [#comment: TODO(samflattery): Remove cleanup in route_fuzz_test.cc when
        implemented]
        """
        pass
    @property
    def non_forwarding_action(self) -> global___NonForwardingAction:
        """[#not-implemented-hide:]
        An action used when the route will generate a response directly,
        without forwarding to an upstream host. This will be used in non-proxy
        xDS clients like the gRPC server. It could also be used in the future
        in Envoy for a filter that directly generates responses for requests.
        """
        pass
    @property
    def metadata(self) -> envoy.config.core.v3.base_pb2.Metadata:
        """The Metadata field can be used to provide additional information
        about the route. It can be used for configuration, stats, and logging.
        The metadata should go under the filter namespace that will need it.
        For instance, if the metadata is intended for the Router filter,
        the filter name should be specified as *envoy.filters.http.router*.
        """
        pass
    @property
    def decorator(self) -> global___Decorator:
        """Decorator for the matched route."""
        pass
    @property
    def typed_per_filter_config(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, google.protobuf.any_pb2.Any]:
        """The typed_per_filter_config field can be used to provide route-specific
        configurations for filters. The key should match the filter name, such as
        *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter
        specific; see the :ref:`HTTP filter documentation <config_http_filters>` for
        if and how it is utilized.
        [#comment: An entry's value may be wrapped in a
        :ref:`FilterConfig<envoy_v3_api_msg_config.route.v3.FilterConfig>`
        message to specify additional options.]
        """
        pass
    @property
    def request_headers_to_add(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[envoy.config.core.v3.base_pb2.HeaderValueOption]:
        """Specifies a set of headers that will be added to requests matching this
        route. Headers specified at this level are applied before headers from the
        enclosing :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost` and
        :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including details on
        header value syntax, see the documentation on :ref:`custom request headers
        <config_http_conn_man_headers_custom_request_headers>`.
        """
        pass
    @property
    def request_headers_to_remove(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Specifies a list of HTTP headers that should be removed from each request
        matching this route.
        """
        pass
    @property
    def response_headers_to_add(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[envoy.config.core.v3.base_pb2.HeaderValueOption]:
        """Specifies a set of headers that will be added to responses to requests
        matching this route. Headers specified at this level are applied before
        headers from the enclosing :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost` and
        :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including
        details on header value syntax, see the documentation on
        :ref:`custom request headers <config_http_conn_man_headers_custom_request_headers>`.
        """
        pass
    @property
    def response_headers_to_remove(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Specifies a list of HTTP headers that should be removed from each response
        to requests matching this route.
        """
        pass
    @property
    def tracing(self) -> global___Tracing:
        """Presence of the object defines whether the connection manager's tracing configuration
        is overridden by this route specific instance.
        """
        pass
    @property
    def per_request_buffer_limit_bytes(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """The maximum bytes which will be buffered for retries and shadowing.
        If set, the bytes actually buffered will be the minimum value of this and the
        listener per_connection_buffer_limit_bytes.
        """
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        match : typing.Optional[global___RouteMatch] = ...,
        route : typing.Optional[global___RouteAction] = ...,
        redirect : typing.Optional[global___RedirectAction] = ...,
        direct_response : typing.Optional[global___DirectResponseAction] = ...,
        filter_action : typing.Optional[global___FilterAction] = ...,
        non_forwarding_action : typing.Optional[global___NonForwardingAction] = ...,
        metadata : typing.Optional[envoy.config.core.v3.base_pb2.Metadata] = ...,
        decorator : typing.Optional[global___Decorator] = ...,
        typed_per_filter_config : typing.Optional[typing.Mapping[typing.Text, google.protobuf.any_pb2.Any]] = ...,
        request_headers_to_add : typing.Optional[typing.Iterable[envoy.config.core.v3.base_pb2.HeaderValueOption]] = ...,
        request_headers_to_remove : typing.Optional[typing.Iterable[typing.Text]] = ...,
        response_headers_to_add : typing.Optional[typing.Iterable[envoy.config.core.v3.base_pb2.HeaderValueOption]] = ...,
        response_headers_to_remove : typing.Optional[typing.Iterable[typing.Text]] = ...,
        tracing : typing.Optional[global___Tracing] = ...,
        per_request_buffer_limit_bytes : typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"action",b"action",u"decorator",b"decorator",u"direct_response",b"direct_response",u"filter_action",b"filter_action",u"match",b"match",u"metadata",b"metadata",u"non_forwarding_action",b"non_forwarding_action",u"per_request_buffer_limit_bytes",b"per_request_buffer_limit_bytes",u"redirect",b"redirect",u"route",b"route",u"tracing",b"tracing"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"action",b"action",u"decorator",b"decorator",u"direct_response",b"direct_response",u"filter_action",b"filter_action",u"match",b"match",u"metadata",b"metadata",u"name",b"name",u"non_forwarding_action",b"non_forwarding_action",u"per_request_buffer_limit_bytes",b"per_request_buffer_limit_bytes",u"redirect",b"redirect",u"request_headers_to_add",b"request_headers_to_add",u"request_headers_to_remove",b"request_headers_to_remove",u"response_headers_to_add",b"response_headers_to_add",u"response_headers_to_remove",b"response_headers_to_remove",u"route",b"route",u"tracing",b"tracing",u"typed_per_filter_config",b"typed_per_filter_config"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"action",b"action"]) -> typing.Optional[typing_extensions.Literal["route","redirect","direct_response","filter_action","non_forwarding_action"]]: ...
global___Route = Route

class WeightedCluster(google.protobuf.message.Message):
    """Compared to the :ref:`cluster <envoy_v3_api_field_config.route.v3.RouteAction.cluster>` field that specifies a
    single upstream cluster as the target of a request, the :ref:`weighted_clusters
    <envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>` option allows for specification of
    multiple upstream clusters along with weights that indicate the percentage of
    traffic to be forwarded to each cluster. The router selects an upstream cluster based on the
    weights.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class ClusterWeight(google.protobuf.message.Message):
        """[#next-free-field: 12]"""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class TypedPerFilterConfigEntry(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            KEY_FIELD_NUMBER: builtins.int
            VALUE_FIELD_NUMBER: builtins.int
            key: typing.Text = ...
            @property
            def value(self) -> google.protobuf.any_pb2.Any: ...
            def __init__(self,
                *,
                key : typing.Text = ...,
                value : typing.Optional[google.protobuf.any_pb2.Any] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal[u"value",b"value"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal[u"key",b"key",u"value",b"value"]) -> None: ...

        NAME_FIELD_NUMBER: builtins.int
        WEIGHT_FIELD_NUMBER: builtins.int
        METADATA_MATCH_FIELD_NUMBER: builtins.int
        REQUEST_HEADERS_TO_ADD_FIELD_NUMBER: builtins.int
        REQUEST_HEADERS_TO_REMOVE_FIELD_NUMBER: builtins.int
        RESPONSE_HEADERS_TO_ADD_FIELD_NUMBER: builtins.int
        RESPONSE_HEADERS_TO_REMOVE_FIELD_NUMBER: builtins.int
        TYPED_PER_FILTER_CONFIG_FIELD_NUMBER: builtins.int
        HOST_REWRITE_LITERAL_FIELD_NUMBER: builtins.int
        name: typing.Text = ...
        """Name of the upstream cluster. The cluster must exist in the
        :ref:`cluster manager configuration <config_cluster_manager>`.
        """

        @property
        def weight(self) -> google.protobuf.wrappers_pb2.UInt32Value:
            """An integer between 0 and :ref:`total_weight
            <envoy_v3_api_field_config.route.v3.WeightedCluster.total_weight>`. When a request matches the route,
            the choice of an upstream cluster is determined by its weight. The sum of weights across all
            entries in the clusters array must add up to the total_weight, which defaults to 100.
            """
            pass
        @property
        def metadata_match(self) -> envoy.config.core.v3.base_pb2.Metadata:
            """Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints in
            the upstream cluster with metadata matching what is set in this field will be considered for
            load balancing. Note that this will be merged with what's provided in
            :ref:`RouteAction.metadata_match <envoy_v3_api_field_config.route.v3.RouteAction.metadata_match>`, with
            values here taking precedence. The filter name should be specified as *envoy.lb*.
            """
            pass
        @property
        def request_headers_to_add(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[envoy.config.core.v3.base_pb2.HeaderValueOption]:
            """Specifies a list of headers to be added to requests when this cluster is selected
            through the enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteAction`.
            Headers specified at this level are applied before headers from the enclosing
            :ref:`envoy_v3_api_msg_config.route.v3.Route`, :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost`, and
            :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including details on
            header value syntax, see the documentation on :ref:`custom request headers
            <config_http_conn_man_headers_custom_request_headers>`.
            """
            pass
        @property
        def request_headers_to_remove(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
            """Specifies a list of HTTP headers that should be removed from each request when
            this cluster is selected through the enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteAction`.
            """
            pass
        @property
        def response_headers_to_add(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[envoy.config.core.v3.base_pb2.HeaderValueOption]:
            """Specifies a list of headers to be added to responses when this cluster is selected
            through the enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteAction`.
            Headers specified at this level are applied before headers from the enclosing
            :ref:`envoy_v3_api_msg_config.route.v3.Route`, :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost`, and
            :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including details on
            header value syntax, see the documentation on :ref:`custom request headers
            <config_http_conn_man_headers_custom_request_headers>`.
            """
            pass
        @property
        def response_headers_to_remove(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
            """Specifies a list of headers to be removed from responses when this cluster is selected
            through the enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteAction`.
            """
            pass
        @property
        def typed_per_filter_config(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, google.protobuf.any_pb2.Any]:
            """The per_filter_config field can be used to provide weighted cluster-specific
            configurations for filters. The key should match the filter name, such as
            *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter
            specific; see the :ref:`HTTP filter documentation <config_http_filters>`
            for if and how it is utilized.
            [#comment: An entry's value may be wrapped in a
            :ref:`FilterConfig<envoy_v3_api_msg_config.route.v3.FilterConfig>`
            message to specify additional options.]
            """
            pass
        host_rewrite_literal: typing.Text = ...
        """Indicates that during forwarding, the host header will be swapped with
        this value.
        """

        def __init__(self,
            *,
            name : typing.Text = ...,
            weight : typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
            metadata_match : typing.Optional[envoy.config.core.v3.base_pb2.Metadata] = ...,
            request_headers_to_add : typing.Optional[typing.Iterable[envoy.config.core.v3.base_pb2.HeaderValueOption]] = ...,
            request_headers_to_remove : typing.Optional[typing.Iterable[typing.Text]] = ...,
            response_headers_to_add : typing.Optional[typing.Iterable[envoy.config.core.v3.base_pb2.HeaderValueOption]] = ...,
            response_headers_to_remove : typing.Optional[typing.Iterable[typing.Text]] = ...,
            typed_per_filter_config : typing.Optional[typing.Mapping[typing.Text, google.protobuf.any_pb2.Any]] = ...,
            host_rewrite_literal : typing.Text = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"host_rewrite_literal",b"host_rewrite_literal",u"host_rewrite_specifier",b"host_rewrite_specifier",u"metadata_match",b"metadata_match",u"weight",b"weight"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"host_rewrite_literal",b"host_rewrite_literal",u"host_rewrite_specifier",b"host_rewrite_specifier",u"metadata_match",b"metadata_match",u"name",b"name",u"request_headers_to_add",b"request_headers_to_add",u"request_headers_to_remove",b"request_headers_to_remove",u"response_headers_to_add",b"response_headers_to_add",u"response_headers_to_remove",b"response_headers_to_remove",u"typed_per_filter_config",b"typed_per_filter_config",u"weight",b"weight"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal[u"host_rewrite_specifier",b"host_rewrite_specifier"]) -> typing.Optional[typing_extensions.Literal["host_rewrite_literal"]]: ...

    CLUSTERS_FIELD_NUMBER: builtins.int
    TOTAL_WEIGHT_FIELD_NUMBER: builtins.int
    RUNTIME_KEY_PREFIX_FIELD_NUMBER: builtins.int
    @property
    def clusters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___WeightedCluster.ClusterWeight]:
        """Specifies one or more upstream clusters associated with the route."""
        pass
    @property
    def total_weight(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """Specifies the total weight across all clusters. The sum of all cluster weights must equal this
        value, which must be greater than 0. Defaults to 100.
        """
        pass
    runtime_key_prefix: typing.Text = ...
    """Specifies the runtime key prefix that should be used to construct the
    runtime keys associated with each cluster. When the *runtime_key_prefix* is
    specified, the router will look for weights associated with each upstream
    cluster under the key *runtime_key_prefix* + "." + *cluster[i].name* where
    *cluster[i]* denotes an entry in the clusters array field. If the runtime
    key for the cluster does not exist, the value specified in the
    configuration file will be used as the default weight. See the :ref:`runtime documentation
    <operations_runtime>` for how key names map to the underlying implementation.
    """

    def __init__(self,
        *,
        clusters : typing.Optional[typing.Iterable[global___WeightedCluster.ClusterWeight]] = ...,
        total_weight : typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        runtime_key_prefix : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"total_weight",b"total_weight"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"clusters",b"clusters",u"runtime_key_prefix",b"runtime_key_prefix",u"total_weight",b"total_weight"]) -> None: ...
global___WeightedCluster = WeightedCluster

class RouteMatch(google.protobuf.message.Message):
    """[#next-free-field: 13]"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class GrpcRouteMatchOptions(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        def __init__(self,
            ) -> None: ...

    class TlsContextMatchOptions(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        PRESENTED_FIELD_NUMBER: builtins.int
        VALIDATED_FIELD_NUMBER: builtins.int
        @property
        def presented(self) -> google.protobuf.wrappers_pb2.BoolValue:
            """If specified, the route will match against whether or not a certificate is presented.
            If not specified, certificate presentation status (true or false) will not be considered when route matching.
            """
            pass
        @property
        def validated(self) -> google.protobuf.wrappers_pb2.BoolValue:
            """If specified, the route will match against whether or not a certificate is validated.
            If not specified, certificate validation status (true or false) will not be considered when route matching.
            """
            pass
        def __init__(self,
            *,
            presented : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
            validated : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"presented",b"presented",u"validated",b"validated"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"presented",b"presented",u"validated",b"validated"]) -> None: ...

    class ConnectMatcher(google.protobuf.message.Message):
        """An extensible message for matching CONNECT requests."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        def __init__(self,
            ) -> None: ...

    PREFIX_FIELD_NUMBER: builtins.int
    PATH_FIELD_NUMBER: builtins.int
    SAFE_REGEX_FIELD_NUMBER: builtins.int
    CONNECT_MATCHER_FIELD_NUMBER: builtins.int
    CASE_SENSITIVE_FIELD_NUMBER: builtins.int
    RUNTIME_FRACTION_FIELD_NUMBER: builtins.int
    HEADERS_FIELD_NUMBER: builtins.int
    QUERY_PARAMETERS_FIELD_NUMBER: builtins.int
    GRPC_FIELD_NUMBER: builtins.int
    TLS_CONTEXT_FIELD_NUMBER: builtins.int
    prefix: typing.Text = ...
    """If specified, the route is a prefix rule meaning that the prefix must
    match the beginning of the *:path* header.
    """

    path: typing.Text = ...
    """If specified, the route is an exact path rule meaning that the path must
    exactly match the *:path* header once the query string is removed.
    """

    @property
    def safe_regex(self) -> envoy.type.matcher.v3.regex_pb2.RegexMatcher:
        """If specified, the route is a regular expression rule meaning that the
        regex must match the *:path* header once the query string is removed. The entire path
        (without the query string) must match the regex. The rule will not match if only a
        subsequence of the *:path* header matches the regex.

        [#next-major-version: In the v3 API we should redo how path specification works such
        that we utilize StringMatcher, and additionally have consistent options around whether we
        strip query strings, do a case sensitive match, etc. In the interim it will be too disruptive
        to deprecate the existing options. We should even consider whether we want to do away with
        path_specifier entirely and just rely on a set of header matchers which can already match
        on :path, etc. The issue with that is it is unclear how to generically deal with query string
        stripping. This needs more thought.]
        """
        pass
    @property
    def connect_matcher(self) -> global___RouteMatch.ConnectMatcher:
        """If this is used as the matcher, the matcher will only match CONNECT requests.
        Note that this will not match HTTP/2 upgrade-style CONNECT requests
        (WebSocket and the like) as they are normalized in Envoy as HTTP/1.1 style
        upgrades.
        This is the only way to match CONNECT requests for HTTP/1.1. For HTTP/2,
        where Extended CONNECT requests may have a path, the path matchers will work if
        there is a path present.
        Note that CONNECT support is currently considered alpha in Envoy.
        [#comment: TODO(htuch): Replace the above comment with an alpha tag.]
        """
        pass
    @property
    def case_sensitive(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """Indicates that prefix/path matching should be case sensitive. The default
        is true. Ignored for safe_regex matching.
        """
        pass
    @property
    def runtime_fraction(self) -> envoy.config.core.v3.base_pb2.RuntimeFractionalPercent:
        """Indicates that the route should additionally match on a runtime key. Every time the route
        is considered for a match, it must also fall under the percentage of matches indicated by
        this field. For some fraction N/D, a random number in the range [0,D) is selected. If the
        number is <= the value of the numerator N, or if the key is not present, the default
        value, the router continues to evaluate the remaining match criteria. A runtime_fraction
        route configuration can be used to roll out route changes in a gradual manner without full
        code/config deploys. Refer to the :ref:`traffic shifting
        <config_http_conn_man_route_table_traffic_splitting_shift>` docs for additional documentation.

        .. note::

           Parsing this field is implemented such that the runtime key's data may be represented
           as a FractionalPercent proto represented as JSON/YAML and may also be represented as an
           integer with the assumption that the value is an integral percentage out of 100. For
           instance, a runtime key lookup returning the value "42" would parse as a FractionalPercent
           whose numerator is 42 and denominator is HUNDRED. This preserves legacy semantics.
        """
        pass
    @property
    def headers(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___HeaderMatcher]:
        """Specifies a set of headers that the route should match on. The router will
        check the requestâ€™s headers against all the specified headers in the route
        config. A match will happen if all the headers in the route are present in
        the request with the same values (or based on presence if the value field
        is not in the config).
        """
        pass
    @property
    def query_parameters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___QueryParameterMatcher]:
        """Specifies a set of URL query parameters on which the route should
        match. The router will check the query string from the *path* header
        against all the specified query parameters. If the number of specified
        query parameters is nonzero, they all must match the *path* header's
        query string for a match to occur.
        """
        pass
    @property
    def grpc(self) -> global___RouteMatch.GrpcRouteMatchOptions:
        """If specified, only gRPC requests will be matched. The router will check
        that the content-type header has a application/grpc or one of the various
        application/grpc+ values.
        """
        pass
    @property
    def tls_context(self) -> global___RouteMatch.TlsContextMatchOptions:
        """If specified, the client tls context will be matched against the defined
        match options.

        [#next-major-version: unify with RBAC]
        """
        pass
    def __init__(self,
        *,
        prefix : typing.Text = ...,
        path : typing.Text = ...,
        safe_regex : typing.Optional[envoy.type.matcher.v3.regex_pb2.RegexMatcher] = ...,
        connect_matcher : typing.Optional[global___RouteMatch.ConnectMatcher] = ...,
        case_sensitive : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
        runtime_fraction : typing.Optional[envoy.config.core.v3.base_pb2.RuntimeFractionalPercent] = ...,
        headers : typing.Optional[typing.Iterable[global___HeaderMatcher]] = ...,
        query_parameters : typing.Optional[typing.Iterable[global___QueryParameterMatcher]] = ...,
        grpc : typing.Optional[global___RouteMatch.GrpcRouteMatchOptions] = ...,
        tls_context : typing.Optional[global___RouteMatch.TlsContextMatchOptions] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"case_sensitive",b"case_sensitive",u"connect_matcher",b"connect_matcher",u"grpc",b"grpc",u"path",b"path",u"path_specifier",b"path_specifier",u"prefix",b"prefix",u"runtime_fraction",b"runtime_fraction",u"safe_regex",b"safe_regex",u"tls_context",b"tls_context"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"case_sensitive",b"case_sensitive",u"connect_matcher",b"connect_matcher",u"grpc",b"grpc",u"headers",b"headers",u"path",b"path",u"path_specifier",b"path_specifier",u"prefix",b"prefix",u"query_parameters",b"query_parameters",u"runtime_fraction",b"runtime_fraction",u"safe_regex",b"safe_regex",u"tls_context",b"tls_context"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"path_specifier",b"path_specifier"]) -> typing.Optional[typing_extensions.Literal["prefix","path","safe_regex","connect_matcher"]]: ...
global___RouteMatch = RouteMatch

class CorsPolicy(google.protobuf.message.Message):
    """[#next-free-field: 12]"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ALLOW_ORIGIN_STRING_MATCH_FIELD_NUMBER: builtins.int
    ALLOW_METHODS_FIELD_NUMBER: builtins.int
    ALLOW_HEADERS_FIELD_NUMBER: builtins.int
    EXPOSE_HEADERS_FIELD_NUMBER: builtins.int
    MAX_AGE_FIELD_NUMBER: builtins.int
    ALLOW_CREDENTIALS_FIELD_NUMBER: builtins.int
    FILTER_ENABLED_FIELD_NUMBER: builtins.int
    SHADOW_ENABLED_FIELD_NUMBER: builtins.int
    @property
    def allow_origin_string_match(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[envoy.type.matcher.v3.string_pb2.StringMatcher]:
        """Specifies string patterns that match allowed origins. An origin is allowed if any of the
        string matchers match.
        """
        pass
    allow_methods: typing.Text = ...
    """Specifies the content for the *access-control-allow-methods* header."""

    allow_headers: typing.Text = ...
    """Specifies the content for the *access-control-allow-headers* header."""

    expose_headers: typing.Text = ...
    """Specifies the content for the *access-control-expose-headers* header."""

    max_age: typing.Text = ...
    """Specifies the content for the *access-control-max-age* header."""

    @property
    def allow_credentials(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """Specifies whether the resource allows credentials."""
        pass
    @property
    def filter_enabled(self) -> envoy.config.core.v3.base_pb2.RuntimeFractionalPercent:
        """Specifies the % of requests for which the CORS filter is enabled.

        If neither ``enabled``, ``filter_enabled``, nor ``shadow_enabled`` are specified, the CORS
        filter will be enabled for 100% of the requests.

        If :ref:`runtime_key <envoy_v3_api_field_config.core.v3.RuntimeFractionalPercent.runtime_key>` is
        specified, Envoy will lookup the runtime key to get the percentage of requests to filter.
        """
        pass
    @property
    def shadow_enabled(self) -> envoy.config.core.v3.base_pb2.RuntimeFractionalPercent:
        """Specifies the % of requests for which the CORS policies will be evaluated and tracked, but not
        enforced.

        This field is intended to be used when ``filter_enabled`` and ``enabled`` are off. One of those
        fields have to explicitly disable the filter in order for this setting to take effect.

        If :ref:`runtime_key <envoy_v3_api_field_config.core.v3.RuntimeFractionalPercent.runtime_key>` is specified,
        Envoy will lookup the runtime key to get the percentage of requests for which it will evaluate
        and track the request's *Origin* to determine if it's valid but will not enforce any policies.
        """
        pass
    def __init__(self,
        *,
        allow_origin_string_match : typing.Optional[typing.Iterable[envoy.type.matcher.v3.string_pb2.StringMatcher]] = ...,
        allow_methods : typing.Text = ...,
        allow_headers : typing.Text = ...,
        expose_headers : typing.Text = ...,
        max_age : typing.Text = ...,
        allow_credentials : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
        filter_enabled : typing.Optional[envoy.config.core.v3.base_pb2.RuntimeFractionalPercent] = ...,
        shadow_enabled : typing.Optional[envoy.config.core.v3.base_pb2.RuntimeFractionalPercent] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"allow_credentials",b"allow_credentials",u"enabled_specifier",b"enabled_specifier",u"filter_enabled",b"filter_enabled",u"shadow_enabled",b"shadow_enabled"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"allow_credentials",b"allow_credentials",u"allow_headers",b"allow_headers",u"allow_methods",b"allow_methods",u"allow_origin_string_match",b"allow_origin_string_match",u"enabled_specifier",b"enabled_specifier",u"expose_headers",b"expose_headers",u"filter_enabled",b"filter_enabled",u"max_age",b"max_age",u"shadow_enabled",b"shadow_enabled"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"enabled_specifier",b"enabled_specifier"]) -> typing.Optional[typing_extensions.Literal["filter_enabled"]]: ...
global___CorsPolicy = CorsPolicy

class RouteAction(google.protobuf.message.Message):
    """[#next-free-field: 38]"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class ClusterNotFoundResponseCode(_ClusterNotFoundResponseCode, metaclass=_ClusterNotFoundResponseCodeEnumTypeWrapper):
        pass
    class _ClusterNotFoundResponseCode:
        V = typing.NewType('V', builtins.int)
    class _ClusterNotFoundResponseCodeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ClusterNotFoundResponseCode.V], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        SERVICE_UNAVAILABLE = RouteAction.ClusterNotFoundResponseCode.V(0)
        """HTTP status code - 503 Service Unavailable."""

        NOT_FOUND = RouteAction.ClusterNotFoundResponseCode.V(1)
        """HTTP status code - 404 Not Found."""


    SERVICE_UNAVAILABLE = RouteAction.ClusterNotFoundResponseCode.V(0)
    """HTTP status code - 503 Service Unavailable."""

    NOT_FOUND = RouteAction.ClusterNotFoundResponseCode.V(1)
    """HTTP status code - 404 Not Found."""


    class InternalRedirectAction(_InternalRedirectAction, metaclass=_InternalRedirectActionEnumTypeWrapper):
        """Configures :ref:`internal redirect <arch_overview_internal_redirects>` behavior.
        [#next-major-version: remove this definition - it's defined in the InternalRedirectPolicy message.]
        """
        pass
    class _InternalRedirectAction:
        V = typing.NewType('V', builtins.int)
    class _InternalRedirectActionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_InternalRedirectAction.V], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        PASS_THROUGH_INTERNAL_REDIRECT = RouteAction.InternalRedirectAction.V(0)
        HANDLE_INTERNAL_REDIRECT = RouteAction.InternalRedirectAction.V(1)

    PASS_THROUGH_INTERNAL_REDIRECT = RouteAction.InternalRedirectAction.V(0)
    HANDLE_INTERNAL_REDIRECT = RouteAction.InternalRedirectAction.V(1)

    class RequestMirrorPolicy(google.protobuf.message.Message):
        """The router is capable of shadowing traffic from one cluster to another. The current
        implementation is "fire and forget," meaning Envoy will not wait for the shadow cluster to
        respond before returning the response from the primary cluster. All normal statistics are
        collected for the shadow cluster making this feature useful for testing.

        During shadowing, the host/authority header is altered such that *-shadow* is appended. This is
        useful for logging. For example, *cluster1* becomes *cluster1-shadow*.

        .. note::

          Shadowing will not be triggered if the primary cluster does not exist.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        CLUSTER_FIELD_NUMBER: builtins.int
        RUNTIME_FRACTION_FIELD_NUMBER: builtins.int
        TRACE_SAMPLED_FIELD_NUMBER: builtins.int
        cluster: typing.Text = ...
        """Specifies the cluster that requests will be mirrored to. The cluster must
        exist in the cluster manager configuration.
        """

        @property
        def runtime_fraction(self) -> envoy.config.core.v3.base_pb2.RuntimeFractionalPercent:
            """If not specified, all requests to the target cluster will be mirrored.

            If specified, this field takes precedence over the `runtime_key` field and requests must also
            fall under the percentage of matches indicated by this field.

            For some fraction N/D, a random number in the range [0,D) is selected. If the
            number is <= the value of the numerator N, or if the key is not present, the default
            value, the request will be mirrored.
            """
            pass
        @property
        def trace_sampled(self) -> google.protobuf.wrappers_pb2.BoolValue:
            """Determines if the trace span should be sampled. Defaults to true."""
            pass
        def __init__(self,
            *,
            cluster : typing.Text = ...,
            runtime_fraction : typing.Optional[envoy.config.core.v3.base_pb2.RuntimeFractionalPercent] = ...,
            trace_sampled : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"runtime_fraction",b"runtime_fraction",u"trace_sampled",b"trace_sampled"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"cluster",b"cluster",u"runtime_fraction",b"runtime_fraction",u"trace_sampled",b"trace_sampled"]) -> None: ...

    class HashPolicy(google.protobuf.message.Message):
        """Specifies the route's hashing policy if the upstream cluster uses a hashing :ref:`load balancer
        <arch_overview_load_balancing_types>`.
        [#next-free-field: 7]
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class Header(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            HEADER_NAME_FIELD_NUMBER: builtins.int
            REGEX_REWRITE_FIELD_NUMBER: builtins.int
            header_name: typing.Text = ...
            """The name of the request header that will be used to obtain the hash
            key. If the request header is not present, no hash will be produced.
            """

            @property
            def regex_rewrite(self) -> envoy.type.matcher.v3.regex_pb2.RegexMatchAndSubstitute:
                """If specified, the request header value will be rewritten and used
                to produce the hash key.
                """
                pass
            def __init__(self,
                *,
                header_name : typing.Text = ...,
                regex_rewrite : typing.Optional[envoy.type.matcher.v3.regex_pb2.RegexMatchAndSubstitute] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal[u"regex_rewrite",b"regex_rewrite"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal[u"header_name",b"header_name",u"regex_rewrite",b"regex_rewrite"]) -> None: ...

        class Cookie(google.protobuf.message.Message):
            """Envoy supports two types of cookie affinity:

            1. Passive. Envoy takes a cookie that's present in the cookies header and
               hashes on its value.

            2. Generated. Envoy generates and sets a cookie with an expiration (TTL)
               on the first request from the client in its response to the client,
               based on the endpoint the request gets sent to. The client then
               presents this on the next and all subsequent requests. The hash of
               this is sufficient to ensure these requests get sent to the same
               endpoint. The cookie is generated by hashing the source and
               destination ports and addresses so that multiple independent HTTP2
               streams on the same connection will independently receive the same
               cookie, even if they arrive at the Envoy simultaneously.
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            NAME_FIELD_NUMBER: builtins.int
            TTL_FIELD_NUMBER: builtins.int
            PATH_FIELD_NUMBER: builtins.int
            name: typing.Text = ...
            """The name of the cookie that will be used to obtain the hash key. If the
            cookie is not present and ttl below is not set, no hash will be
            produced.
            """

            @property
            def ttl(self) -> google.protobuf.duration_pb2.Duration:
                """If specified, a cookie with the TTL will be generated if the cookie is
                not present. If the TTL is present and zero, the generated cookie will
                be a session cookie.
                """
                pass
            path: typing.Text = ...
            """The name of the path for the cookie. If no path is specified here, no path
            will be set for the cookie.
            """

            def __init__(self,
                *,
                name : typing.Text = ...,
                ttl : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
                path : typing.Text = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal[u"ttl",b"ttl"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal[u"name",b"name",u"path",b"path",u"ttl",b"ttl"]) -> None: ...

        class ConnectionProperties(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            SOURCE_IP_FIELD_NUMBER: builtins.int
            source_ip: builtins.bool = ...
            """Hash on source IP address."""

            def __init__(self,
                *,
                source_ip : builtins.bool = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal[u"source_ip",b"source_ip"]) -> None: ...

        class QueryParameter(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            NAME_FIELD_NUMBER: builtins.int
            name: typing.Text = ...
            """The name of the URL query parameter that will be used to obtain the hash
            key. If the parameter is not present, no hash will be produced. Query
            parameter names are case-sensitive.
            """

            def __init__(self,
                *,
                name : typing.Text = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal[u"name",b"name"]) -> None: ...

        class FilterState(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            KEY_FIELD_NUMBER: builtins.int
            key: typing.Text = ...
            """The name of the Object in the per-request filterState, which is an
            Envoy::Http::Hashable object. If there is no data associated with the key,
            or the stored object is not Envoy::Http::Hashable, no hash will be produced.
            """

            def __init__(self,
                *,
                key : typing.Text = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal[u"key",b"key"]) -> None: ...

        HEADER_FIELD_NUMBER: builtins.int
        COOKIE_FIELD_NUMBER: builtins.int
        CONNECTION_PROPERTIES_FIELD_NUMBER: builtins.int
        QUERY_PARAMETER_FIELD_NUMBER: builtins.int
        FILTER_STATE_FIELD_NUMBER: builtins.int
        TERMINAL_FIELD_NUMBER: builtins.int
        @property
        def header(self) -> global___RouteAction.HashPolicy.Header:
            """Header hash policy."""
            pass
        @property
        def cookie(self) -> global___RouteAction.HashPolicy.Cookie:
            """Cookie hash policy."""
            pass
        @property
        def connection_properties(self) -> global___RouteAction.HashPolicy.ConnectionProperties:
            """Connection properties hash policy."""
            pass
        @property
        def query_parameter(self) -> global___RouteAction.HashPolicy.QueryParameter:
            """Query parameter hash policy."""
            pass
        @property
        def filter_state(self) -> global___RouteAction.HashPolicy.FilterState:
            """Filter state hash policy."""
            pass
        terminal: builtins.bool = ...
        """The flag that short-circuits the hash computing. This field provides a
        'fallback' style of configuration: "if a terminal policy doesn't work,
        fallback to rest of the policy list", it saves time when the terminal
        policy works.

        If true, and there is already a hash computed, ignore rest of the
        list of hash polices.
        For example, if the following hash methods are configured:

         ========= ========
         specifier terminal
         ========= ========
         Header A  true
         Header B  false
         Header C  false
         ========= ========

        The generateHash process ends if policy "header A" generates a hash, as
        it's a terminal policy.
        """

        def __init__(self,
            *,
            header : typing.Optional[global___RouteAction.HashPolicy.Header] = ...,
            cookie : typing.Optional[global___RouteAction.HashPolicy.Cookie] = ...,
            connection_properties : typing.Optional[global___RouteAction.HashPolicy.ConnectionProperties] = ...,
            query_parameter : typing.Optional[global___RouteAction.HashPolicy.QueryParameter] = ...,
            filter_state : typing.Optional[global___RouteAction.HashPolicy.FilterState] = ...,
            terminal : builtins.bool = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"connection_properties",b"connection_properties",u"cookie",b"cookie",u"filter_state",b"filter_state",u"header",b"header",u"policy_specifier",b"policy_specifier",u"query_parameter",b"query_parameter"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"connection_properties",b"connection_properties",u"cookie",b"cookie",u"filter_state",b"filter_state",u"header",b"header",u"policy_specifier",b"policy_specifier",u"query_parameter",b"query_parameter",u"terminal",b"terminal"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal[u"policy_specifier",b"policy_specifier"]) -> typing.Optional[typing_extensions.Literal["header","cookie","connection_properties","query_parameter","filter_state"]]: ...

    class UpgradeConfig(google.protobuf.message.Message):
        """Allows enabling and disabling upgrades on a per-route basis.
        This overrides any enabled/disabled upgrade filter chain specified in the
        HttpConnectionManager
        :ref:`upgrade_configs
        <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.upgrade_configs>`
        but does not affect any custom filter chain specified there.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class ConnectConfig(google.protobuf.message.Message):
            """Configuration for sending data upstream as a raw data payload. This is used for
            CONNECT or POST requests, when forwarding request payload as raw TCP.
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            PROXY_PROTOCOL_CONFIG_FIELD_NUMBER: builtins.int
            ALLOW_POST_FIELD_NUMBER: builtins.int
            @property
            def proxy_protocol_config(self) -> envoy.config.core.v3.proxy_protocol_pb2.ProxyProtocolConfig:
                """If present, the proxy protocol header will be prepended to the CONNECT payload sent upstream."""
                pass
            allow_post: builtins.bool = ...
            """If set, the route will also allow forwarding POST payload as raw TCP."""

            def __init__(self,
                *,
                proxy_protocol_config : typing.Optional[envoy.config.core.v3.proxy_protocol_pb2.ProxyProtocolConfig] = ...,
                allow_post : builtins.bool = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal[u"proxy_protocol_config",b"proxy_protocol_config"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal[u"allow_post",b"allow_post",u"proxy_protocol_config",b"proxy_protocol_config"]) -> None: ...

        UPGRADE_TYPE_FIELD_NUMBER: builtins.int
        ENABLED_FIELD_NUMBER: builtins.int
        CONNECT_CONFIG_FIELD_NUMBER: builtins.int
        upgrade_type: typing.Text = ...
        """The case-insensitive name of this upgrade, e.g. "websocket".
        For each upgrade type present in upgrade_configs, requests with
        Upgrade: [upgrade_type] will be proxied upstream.
        """

        @property
        def enabled(self) -> google.protobuf.wrappers_pb2.BoolValue:
            """Determines if upgrades are available on this route. Defaults to true."""
            pass
        @property
        def connect_config(self) -> global___RouteAction.UpgradeConfig.ConnectConfig:
            """Configuration for sending data upstream as a raw data payload. This is used for
            CONNECT requests, when forwarding CONNECT payload as raw TCP.
            Note that CONNECT support is currently considered alpha in Envoy.
            [#comment: TODO(htuch): Replace the above comment with an alpha tag.]
            """
            pass
        def __init__(self,
            *,
            upgrade_type : typing.Text = ...,
            enabled : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
            connect_config : typing.Optional[global___RouteAction.UpgradeConfig.ConnectConfig] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"connect_config",b"connect_config",u"enabled",b"enabled"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"connect_config",b"connect_config",u"enabled",b"enabled",u"upgrade_type",b"upgrade_type"]) -> None: ...

    class MaxStreamDuration(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        MAX_STREAM_DURATION_FIELD_NUMBER: builtins.int
        GRPC_TIMEOUT_HEADER_MAX_FIELD_NUMBER: builtins.int
        GRPC_TIMEOUT_HEADER_OFFSET_FIELD_NUMBER: builtins.int
        @property
        def max_stream_duration(self) -> google.protobuf.duration_pb2.Duration:
            """Specifies the maximum duration allowed for streams on the route. If not specified, the value
            from the :ref:`max_stream_duration
            <envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration>` field in
            :ref:`HttpConnectionManager.common_http_protocol_options
            <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.common_http_protocol_options>`
            is used. If this field is set explicitly to zero, any
            HttpConnectionManager max_stream_duration timeout will be disabled for
            this route.
            """
            pass
        @property
        def grpc_timeout_header_max(self) -> google.protobuf.duration_pb2.Duration:
            """If present, and the request contains a `grpc-timeout header
            <https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md>`_, use that value as the
            *max_stream_duration*, but limit the applied timeout to the maximum value specified here.
            If set to 0, the `grpc-timeout` header is used without modification.
            """
            pass
        @property
        def grpc_timeout_header_offset(self) -> google.protobuf.duration_pb2.Duration:
            """If present, Envoy will adjust the timeout provided by the `grpc-timeout` header by
            subtracting the provided duration from the header. This is useful for allowing Envoy to set
            its global timeout to be less than that of the deadline imposed by the calling client, which
            makes it more likely that Envoy will handle the timeout instead of having the call canceled
            by the client. If, after applying the offset, the resulting timeout is zero or negative,
            the stream will timeout immediately.
            """
            pass
        def __init__(self,
            *,
            max_stream_duration : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
            grpc_timeout_header_max : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
            grpc_timeout_header_offset : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"grpc_timeout_header_max",b"grpc_timeout_header_max",u"grpc_timeout_header_offset",b"grpc_timeout_header_offset",u"max_stream_duration",b"max_stream_duration"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"grpc_timeout_header_max",b"grpc_timeout_header_max",u"grpc_timeout_header_offset",b"grpc_timeout_header_offset",u"max_stream_duration",b"max_stream_duration"]) -> None: ...

    CLUSTER_FIELD_NUMBER: builtins.int
    CLUSTER_HEADER_FIELD_NUMBER: builtins.int
    WEIGHTED_CLUSTERS_FIELD_NUMBER: builtins.int
    CLUSTER_SPECIFIER_PLUGIN_FIELD_NUMBER: builtins.int
    CLUSTER_NOT_FOUND_RESPONSE_CODE_FIELD_NUMBER: builtins.int
    METADATA_MATCH_FIELD_NUMBER: builtins.int
    PREFIX_REWRITE_FIELD_NUMBER: builtins.int
    REGEX_REWRITE_FIELD_NUMBER: builtins.int
    HOST_REWRITE_LITERAL_FIELD_NUMBER: builtins.int
    AUTO_HOST_REWRITE_FIELD_NUMBER: builtins.int
    HOST_REWRITE_HEADER_FIELD_NUMBER: builtins.int
    HOST_REWRITE_PATH_REGEX_FIELD_NUMBER: builtins.int
    TIMEOUT_FIELD_NUMBER: builtins.int
    IDLE_TIMEOUT_FIELD_NUMBER: builtins.int
    RETRY_POLICY_FIELD_NUMBER: builtins.int
    RETRY_POLICY_TYPED_CONFIG_FIELD_NUMBER: builtins.int
    REQUEST_MIRROR_POLICIES_FIELD_NUMBER: builtins.int
    PRIORITY_FIELD_NUMBER: builtins.int
    RATE_LIMITS_FIELD_NUMBER: builtins.int
    INCLUDE_VH_RATE_LIMITS_FIELD_NUMBER: builtins.int
    HASH_POLICY_FIELD_NUMBER: builtins.int
    CORS_FIELD_NUMBER: builtins.int
    MAX_GRPC_TIMEOUT_FIELD_NUMBER: builtins.int
    GRPC_TIMEOUT_OFFSET_FIELD_NUMBER: builtins.int
    UPGRADE_CONFIGS_FIELD_NUMBER: builtins.int
    INTERNAL_REDIRECT_POLICY_FIELD_NUMBER: builtins.int
    INTERNAL_REDIRECT_ACTION_FIELD_NUMBER: builtins.int
    MAX_INTERNAL_REDIRECTS_FIELD_NUMBER: builtins.int
    HEDGE_POLICY_FIELD_NUMBER: builtins.int
    MAX_STREAM_DURATION_FIELD_NUMBER: builtins.int
    cluster: typing.Text = ...
    """Indicates the upstream cluster to which the request should be routed
    to.
    """

    cluster_header: typing.Text = ...
    """Envoy will determine the cluster to route to by reading the value of the
    HTTP header named by cluster_header from the request headers. If the
    header is not found or the referenced cluster does not exist, Envoy will
    return a 404 response.

    .. attention::

      Internally, Envoy always uses the HTTP/2 *:authority* header to represent the HTTP/1
      *Host* header. Thus, if attempting to match on *Host*, match on *:authority* instead.

    .. note::

      If the header appears multiple times only the first value is used.
    """

    @property
    def weighted_clusters(self) -> global___WeightedCluster:
        """Multiple upstream clusters can be specified for a given route. The
        request is routed to one of the upstream clusters based on weights
        assigned to each cluster. See
        :ref:`traffic splitting <config_http_conn_man_route_table_traffic_splitting_split>`
        for additional documentation.
        """
        pass
    cluster_specifier_plugin: typing.Text = ...
    """[#not-implemented-hide:]
    Name of the cluster specifier plugin to use to determine the cluster for
    requests on this route. The plugin name must be defined in the associated
    :ref:`envoy_v3_api_field_config.route.v3.RouteConfiguration.cluster_specifier_plugins`
    in the
    :ref:`envoy_v3_api_field_config.core.v3.TypedExtensionConfig.name` field.
    """

    cluster_not_found_response_code: global___RouteAction.ClusterNotFoundResponseCode.V = ...
    """The HTTP status code to use when configured cluster is not found.
    The default response code is 503 Service Unavailable.
    """

    @property
    def metadata_match(self) -> envoy.config.core.v3.base_pb2.Metadata:
        """Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
        in the upstream cluster with metadata matching what's set in this field will be considered
        for load balancing. If using :ref:`weighted_clusters
        <envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>`, metadata will be merged, with values
        provided there taking precedence. The filter name should be specified as *envoy.lb*.
        """
        pass
    prefix_rewrite: typing.Text = ...
    """Indicates that during forwarding, the matched prefix (or path) should be
    swapped with this value. This option allows application URLs to be rooted
    at a different path from those exposed at the reverse proxy layer. The router filter will
    place the original path before rewrite into the :ref:`x-envoy-original-path
    <config_http_filters_router_x-envoy-original-path>` header.

    Only one of *prefix_rewrite* or
    :ref:`regex_rewrite <envoy_v3_api_field_config.route.v3.RouteAction.regex_rewrite>`
    may be specified.

    .. attention::

      Pay careful attention to the use of trailing slashes in the
      :ref:`route's match <envoy_v3_api_field_config.route.v3.Route.match>` prefix value.
      Stripping a prefix from a path requires multiple Routes to handle all cases. For example,
      rewriting */prefix* to */* and */prefix/etc* to */etc* cannot be done in a single
      :ref:`Route <envoy_v3_api_msg_config.route.v3.Route>`, as shown by the below config entries:

      .. code-block:: yaml

        - match:
            prefix: "/prefix/"
          route:
            prefix_rewrite: "/"
        - match:
            prefix: "/prefix"
          route:
            prefix_rewrite: "/"

      Having above entries in the config, requests to */prefix* will be stripped to */*, while
      requests to */prefix/etc* will be stripped to */etc*.
    """

    @property
    def regex_rewrite(self) -> envoy.type.matcher.v3.regex_pb2.RegexMatchAndSubstitute:
        """Indicates that during forwarding, portions of the path that match the
        pattern should be rewritten, even allowing the substitution of capture
        groups from the pattern into the new path as specified by the rewrite
        substitution string. This is useful to allow application paths to be
        rewritten in a way that is aware of segments with variable content like
        identifiers. The router filter will place the original path as it was
        before the rewrite into the :ref:`x-envoy-original-path
        <config_http_filters_router_x-envoy-original-path>` header.

        Only one of :ref:`prefix_rewrite <envoy_v3_api_field_config.route.v3.RouteAction.prefix_rewrite>`
        or *regex_rewrite* may be specified.

        Examples using Google's `RE2 <https://github.com/google/re2>`_ engine:

        * The path pattern ``^/service/([^/]+)(/.*)$`` paired with a substitution
          string of ``\2/instance/\1`` would transform ``/service/foo/v1/api``
          into ``/v1/api/instance/foo``.

        * The pattern ``one`` paired with a substitution string of ``two`` would
          transform ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/two/zzz``.

        * The pattern ``^(.*?)one(.*)$`` paired with a substitution string of
          ``\1two\2`` would replace only the first occurrence of ``one``,
          transforming path ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/one/zzz``.

        * The pattern ``(?i)/xxx/`` paired with a substitution string of ``/yyy/``
          would do a case-insensitive match and transform path ``/aaa/XxX/bbb`` to
          ``/aaa/yyy/bbb``.
        """
        pass
    host_rewrite_literal: typing.Text = ...
    """Indicates that during forwarding, the host header will be swapped with
    this value.
    """

    @property
    def auto_host_rewrite(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """Indicates that during forwarding, the host header will be swapped with
        the hostname of the upstream host chosen by the cluster manager. This
        option is applicable only when the destination cluster for a route is of
        type *strict_dns* or *logical_dns*. Setting this to true with other cluster
        types has no effect.
        """
        pass
    host_rewrite_header: typing.Text = ...
    """Indicates that during forwarding, the host header will be swapped with the content of given
    downstream or :ref:`custom <config_http_conn_man_headers_custom_request_headers>` header.
    If header value is empty, host header is left intact.

    .. attention::

      Pay attention to the potential security implications of using this option. Provided header
      must come from trusted source.

    .. note::

      If the header appears multiple times only the first value is used.
    """

    @property
    def host_rewrite_path_regex(self) -> envoy.type.matcher.v3.regex_pb2.RegexMatchAndSubstitute:
        """Indicates that during forwarding, the host header will be swapped with
        the result of the regex substitution executed on path value with query and fragment removed.
        This is useful for transitioning variable content between path segment and subdomain.

        For example with the following config:

          .. code-block:: yaml

            host_rewrite_path_regex:
              pattern:
                google_re2: {}
                regex: "^/(.+)/.+$"
              substitution: \1

        Would rewrite the host header to `envoyproxy.io` given the path `/envoyproxy.io/some/path`.
        """
        pass
    @property
    def timeout(self) -> google.protobuf.duration_pb2.Duration:
        """Specifies the upstream timeout for the route. If not specified, the default is 15s. This
        spans between the point at which the entire downstream request (i.e. end-of-stream) has been
        processed and when the upstream response has been completely processed. A value of 0 will
        disable the route's timeout.

        .. note::

          This timeout includes all retries. See also
          :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
          :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
          :ref:`retry overview <arch_overview_http_routing_retry>`.
        """
        pass
    @property
    def idle_timeout(self) -> google.protobuf.duration_pb2.Duration:
        """Specifies the idle timeout for the route. If not specified, there is no per-route idle timeout,
        although the connection manager wide :ref:`stream_idle_timeout
        <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout>`
        will still apply. A value of 0 will completely disable the route's idle timeout, even if a
        connection manager stream idle timeout is configured.

        The idle timeout is distinct to :ref:`timeout
        <envoy_v3_api_field_config.route.v3.RouteAction.timeout>`, which provides an upper bound
        on the upstream response time; :ref:`idle_timeout
        <envoy_v3_api_field_config.route.v3.RouteAction.idle_timeout>` instead bounds the amount
        of time the request's stream may be idle.

        After header decoding, the idle timeout will apply on downstream and
        upstream request events. Each time an encode/decode event for headers or
        data is processed for the stream, the timer will be reset. If the timeout
        fires, the stream is terminated with a 408 Request Timeout error code if no
        upstream response header has been received, otherwise a stream reset
        occurs.

        If the :ref:`overload action <config_overload_manager_overload_actions>` "envoy.overload_actions.reduce_timeouts"
        is configured, this timeout is scaled according to the value for
        :ref:`HTTP_DOWNSTREAM_STREAM_IDLE <envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE>`.
        """
        pass
    @property
    def retry_policy(self) -> global___RetryPolicy:
        """Indicates that the route has a retry policy. Note that if this is set,
        it'll take precedence over the virtual host level retry policy entirely
        (e.g.: policies are not merged, most internal one becomes the enforced policy).
        """
        pass
    @property
    def retry_policy_typed_config(self) -> google.protobuf.any_pb2.Any:
        """[#not-implemented-hide:]
        Specifies the configuration for retry policy extension. Note that if this is set, it'll take
        precedence over the virtual host level retry policy entirely (e.g.: policies are not merged,
        most internal one becomes the enforced policy). :ref:`Retry policy <envoy_v3_api_field_config.route.v3.VirtualHost.retry_policy>`
        should not be set if this field is used.
        """
        pass
    @property
    def request_mirror_policies(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RouteAction.RequestMirrorPolicy]:
        """Indicates that the route has request mirroring policies."""
        pass
    priority: envoy.config.core.v3.base_pb2.RoutingPriority.V = ...
    """Optionally specifies the :ref:`routing priority <arch_overview_http_routing_priority>`."""

    @property
    def rate_limits(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RateLimit]:
        """Specifies a set of rate limit configurations that could be applied to the
        route.
        """
        pass
    @property
    def include_vh_rate_limits(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """Specifies if the rate limit filter should include the virtual host rate
        limits. By default, if the route configured rate limits, the virtual host
        :ref:`rate_limits <envoy_v3_api_field_config.route.v3.VirtualHost.rate_limits>` are not applied to the
        request.

        This field is deprecated. Please use :ref:`vh_rate_limits <envoy_v3_api_field_extensions.filters.http.ratelimit.v3.RateLimitPerRoute.vh_rate_limits>`
        """
        pass
    @property
    def hash_policy(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RouteAction.HashPolicy]:
        """Specifies a list of hash policies to use for ring hash load balancing. Each
        hash policy is evaluated individually and the combined result is used to
        route the request. The method of combination is deterministic such that
        identical lists of hash policies will produce the same hash. Since a hash
        policy examines specific parts of a request, it can fail to produce a hash
        (i.e. if the hashed header is not present). If (and only if) all configured
        hash policies fail to generate a hash, no hash will be produced for
        the route. In this case, the behavior is the same as if no hash policies
        were specified (i.e. the ring hash load balancer will choose a random
        backend). If a hash policy has the "terminal" attribute set to true, and
        there is already a hash generated, the hash is returned immediately,
        ignoring the rest of the hash policy list.
        """
        pass
    @property
    def cors(self) -> global___CorsPolicy:
        """Indicates that the route has a CORS policy."""
        pass
    @property
    def max_grpc_timeout(self) -> google.protobuf.duration_pb2.Duration:
        """Deprecated by :ref:`grpc_timeout_header_max <envoy_v3_api_field_config.route.v3.RouteAction.MaxStreamDuration.grpc_timeout_header_max>`
        If present, and the request is a gRPC request, use the
        `grpc-timeout header <https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md>`_,
        or its default value (infinity) instead of
        :ref:`timeout <envoy_v3_api_field_config.route.v3.RouteAction.timeout>`, but limit the applied timeout
        to the maximum value specified here. If configured as 0, the maximum allowed timeout for
        gRPC requests is infinity. If not configured at all, the `grpc-timeout` header is not used
        and gRPC requests time out like any other requests using
        :ref:`timeout <envoy_v3_api_field_config.route.v3.RouteAction.timeout>` or its default.
        This can be used to prevent unexpected upstream request timeouts due to potentially long
        time gaps between gRPC request and response in gRPC streaming mode.

        .. note::

           If a timeout is specified using :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`, it takes
           precedence over `grpc-timeout header <https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md>`_, when
           both are present. See also
           :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
           :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
           :ref:`retry overview <arch_overview_http_routing_retry>`.
        """
        pass
    @property
    def grpc_timeout_offset(self) -> google.protobuf.duration_pb2.Duration:
        """Deprecated by :ref:`grpc_timeout_header_offset <envoy_v3_api_field_config.route.v3.RouteAction.MaxStreamDuration.grpc_timeout_header_offset>`.
        If present, Envoy will adjust the timeout provided by the `grpc-timeout` header by subtracting
        the provided duration from the header. This is useful in allowing Envoy to set its global
        timeout to be less than that of the deadline imposed by the calling client, which makes it more
        likely that Envoy will handle the timeout instead of having the call canceled by the client.
        The offset will only be applied if the provided grpc_timeout is greater than the offset. This
        ensures that the offset will only ever decrease the timeout and never set it to 0 (meaning
        infinity).
        """
        pass
    @property
    def upgrade_configs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RouteAction.UpgradeConfig]: ...
    @property
    def internal_redirect_policy(self) -> global___InternalRedirectPolicy:
        """If present, Envoy will try to follow an upstream redirect response instead of proxying the
        response back to the downstream. An upstream redirect response is defined
        by :ref:`redirect_response_codes
        <envoy_v3_api_field_config.route.v3.InternalRedirectPolicy.redirect_response_codes>`.
        """
        pass
    internal_redirect_action: global___RouteAction.InternalRedirectAction.V = ...
    @property
    def max_internal_redirects(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """An internal redirect is handled, iff the number of previous internal redirects that a
        downstream request has encountered is lower than this value, and
        :ref:`internal_redirect_action <envoy_v3_api_field_config.route.v3.RouteAction.internal_redirect_action>`
        is set to :ref:`HANDLE_INTERNAL_REDIRECT
        <envoy_v3_api_enum_value_config.route.v3.RouteAction.InternalRedirectAction.HANDLE_INTERNAL_REDIRECT>`
        In the case where a downstream request is bounced among multiple routes by internal redirect,
        the first route that hits this threshold, or has
        :ref:`internal_redirect_action <envoy_v3_api_field_config.route.v3.RouteAction.internal_redirect_action>`
        set to
        :ref:`PASS_THROUGH_INTERNAL_REDIRECT
        <envoy_v3_api_enum_value_config.route.v3.RouteAction.InternalRedirectAction.PASS_THROUGH_INTERNAL_REDIRECT>`
        will pass the redirect back to downstream.

        If not specified, at most one redirect will be followed.
        """
        pass
    @property
    def hedge_policy(self) -> global___HedgePolicy:
        """Indicates that the route has a hedge policy. Note that if this is set,
        it'll take precedence over the virtual host level hedge policy entirely
        (e.g.: policies are not merged, most internal one becomes the enforced policy).
        """
        pass
    @property
    def max_stream_duration(self) -> global___RouteAction.MaxStreamDuration:
        """Specifies the maximum stream duration for this route."""
        pass
    def __init__(self,
        *,
        cluster : typing.Text = ...,
        cluster_header : typing.Text = ...,
        weighted_clusters : typing.Optional[global___WeightedCluster] = ...,
        cluster_specifier_plugin : typing.Text = ...,
        cluster_not_found_response_code : global___RouteAction.ClusterNotFoundResponseCode.V = ...,
        metadata_match : typing.Optional[envoy.config.core.v3.base_pb2.Metadata] = ...,
        prefix_rewrite : typing.Text = ...,
        regex_rewrite : typing.Optional[envoy.type.matcher.v3.regex_pb2.RegexMatchAndSubstitute] = ...,
        host_rewrite_literal : typing.Text = ...,
        auto_host_rewrite : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
        host_rewrite_header : typing.Text = ...,
        host_rewrite_path_regex : typing.Optional[envoy.type.matcher.v3.regex_pb2.RegexMatchAndSubstitute] = ...,
        timeout : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        idle_timeout : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        retry_policy : typing.Optional[global___RetryPolicy] = ...,
        retry_policy_typed_config : typing.Optional[google.protobuf.any_pb2.Any] = ...,
        request_mirror_policies : typing.Optional[typing.Iterable[global___RouteAction.RequestMirrorPolicy]] = ...,
        priority : envoy.config.core.v3.base_pb2.RoutingPriority.V = ...,
        rate_limits : typing.Optional[typing.Iterable[global___RateLimit]] = ...,
        include_vh_rate_limits : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
        hash_policy : typing.Optional[typing.Iterable[global___RouteAction.HashPolicy]] = ...,
        cors : typing.Optional[global___CorsPolicy] = ...,
        max_grpc_timeout : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        grpc_timeout_offset : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        upgrade_configs : typing.Optional[typing.Iterable[global___RouteAction.UpgradeConfig]] = ...,
        internal_redirect_policy : typing.Optional[global___InternalRedirectPolicy] = ...,
        internal_redirect_action : global___RouteAction.InternalRedirectAction.V = ...,
        max_internal_redirects : typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        hedge_policy : typing.Optional[global___HedgePolicy] = ...,
        max_stream_duration : typing.Optional[global___RouteAction.MaxStreamDuration] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"auto_host_rewrite",b"auto_host_rewrite",u"cluster",b"cluster",u"cluster_header",b"cluster_header",u"cluster_specifier",b"cluster_specifier",u"cluster_specifier_plugin",b"cluster_specifier_plugin",u"cors",b"cors",u"grpc_timeout_offset",b"grpc_timeout_offset",u"hedge_policy",b"hedge_policy",u"host_rewrite_header",b"host_rewrite_header",u"host_rewrite_literal",b"host_rewrite_literal",u"host_rewrite_path_regex",b"host_rewrite_path_regex",u"host_rewrite_specifier",b"host_rewrite_specifier",u"idle_timeout",b"idle_timeout",u"include_vh_rate_limits",b"include_vh_rate_limits",u"internal_redirect_policy",b"internal_redirect_policy",u"max_grpc_timeout",b"max_grpc_timeout",u"max_internal_redirects",b"max_internal_redirects",u"max_stream_duration",b"max_stream_duration",u"metadata_match",b"metadata_match",u"regex_rewrite",b"regex_rewrite",u"retry_policy",b"retry_policy",u"retry_policy_typed_config",b"retry_policy_typed_config",u"timeout",b"timeout",u"weighted_clusters",b"weighted_clusters"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"auto_host_rewrite",b"auto_host_rewrite",u"cluster",b"cluster",u"cluster_header",b"cluster_header",u"cluster_not_found_response_code",b"cluster_not_found_response_code",u"cluster_specifier",b"cluster_specifier",u"cluster_specifier_plugin",b"cluster_specifier_plugin",u"cors",b"cors",u"grpc_timeout_offset",b"grpc_timeout_offset",u"hash_policy",b"hash_policy",u"hedge_policy",b"hedge_policy",u"host_rewrite_header",b"host_rewrite_header",u"host_rewrite_literal",b"host_rewrite_literal",u"host_rewrite_path_regex",b"host_rewrite_path_regex",u"host_rewrite_specifier",b"host_rewrite_specifier",u"idle_timeout",b"idle_timeout",u"include_vh_rate_limits",b"include_vh_rate_limits",u"internal_redirect_action",b"internal_redirect_action",u"internal_redirect_policy",b"internal_redirect_policy",u"max_grpc_timeout",b"max_grpc_timeout",u"max_internal_redirects",b"max_internal_redirects",u"max_stream_duration",b"max_stream_duration",u"metadata_match",b"metadata_match",u"prefix_rewrite",b"prefix_rewrite",u"priority",b"priority",u"rate_limits",b"rate_limits",u"regex_rewrite",b"regex_rewrite",u"request_mirror_policies",b"request_mirror_policies",u"retry_policy",b"retry_policy",u"retry_policy_typed_config",b"retry_policy_typed_config",u"timeout",b"timeout",u"upgrade_configs",b"upgrade_configs",u"weighted_clusters",b"weighted_clusters"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"cluster_specifier",b"cluster_specifier"]) -> typing.Optional[typing_extensions.Literal["cluster","cluster_header","weighted_clusters","cluster_specifier_plugin"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"host_rewrite_specifier",b"host_rewrite_specifier"]) -> typing.Optional[typing_extensions.Literal["host_rewrite_literal","auto_host_rewrite","host_rewrite_header","host_rewrite_path_regex"]]: ...
global___RouteAction = RouteAction

class RetryPolicy(google.protobuf.message.Message):
    """HTTP retry :ref:`architecture overview <arch_overview_http_routing_retry>`.
    [#next-free-field: 12]
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class ResetHeaderFormat(_ResetHeaderFormat, metaclass=_ResetHeaderFormatEnumTypeWrapper):
        pass
    class _ResetHeaderFormat:
        V = typing.NewType('V', builtins.int)
    class _ResetHeaderFormatEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ResetHeaderFormat.V], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        SECONDS = RetryPolicy.ResetHeaderFormat.V(0)
        UNIX_TIMESTAMP = RetryPolicy.ResetHeaderFormat.V(1)

    SECONDS = RetryPolicy.ResetHeaderFormat.V(0)
    UNIX_TIMESTAMP = RetryPolicy.ResetHeaderFormat.V(1)

    class RetryPriority(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        NAME_FIELD_NUMBER: builtins.int
        TYPED_CONFIG_FIELD_NUMBER: builtins.int
        name: typing.Text = ...
        @property
        def typed_config(self) -> google.protobuf.any_pb2.Any: ...
        def __init__(self,
            *,
            name : typing.Text = ...,
            typed_config : typing.Optional[google.protobuf.any_pb2.Any] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"config_type",b"config_type",u"typed_config",b"typed_config"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"config_type",b"config_type",u"name",b"name",u"typed_config",b"typed_config"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal[u"config_type",b"config_type"]) -> typing.Optional[typing_extensions.Literal["typed_config"]]: ...

    class RetryHostPredicate(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        NAME_FIELD_NUMBER: builtins.int
        TYPED_CONFIG_FIELD_NUMBER: builtins.int
        name: typing.Text = ...
        @property
        def typed_config(self) -> google.protobuf.any_pb2.Any: ...
        def __init__(self,
            *,
            name : typing.Text = ...,
            typed_config : typing.Optional[google.protobuf.any_pb2.Any] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"config_type",b"config_type",u"typed_config",b"typed_config"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"config_type",b"config_type",u"name",b"name",u"typed_config",b"typed_config"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal[u"config_type",b"config_type"]) -> typing.Optional[typing_extensions.Literal["typed_config"]]: ...

    class RetryBackOff(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        BASE_INTERVAL_FIELD_NUMBER: builtins.int
        MAX_INTERVAL_FIELD_NUMBER: builtins.int
        @property
        def base_interval(self) -> google.protobuf.duration_pb2.Duration:
            """Specifies the base interval between retries. This parameter is required and must be greater
            than zero. Values less than 1 ms are rounded up to 1 ms.
            See :ref:`config_http_filters_router_x-envoy-max-retries` for a discussion of Envoy's
            back-off algorithm.
            """
            pass
        @property
        def max_interval(self) -> google.protobuf.duration_pb2.Duration:
            """Specifies the maximum interval between retries. This parameter is optional, but must be
            greater than or equal to the `base_interval` if set. The default is 10 times the
            `base_interval`. See :ref:`config_http_filters_router_x-envoy-max-retries` for a discussion
            of Envoy's back-off algorithm.
            """
            pass
        def __init__(self,
            *,
            base_interval : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
            max_interval : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"base_interval",b"base_interval",u"max_interval",b"max_interval"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"base_interval",b"base_interval",u"max_interval",b"max_interval"]) -> None: ...

    class ResetHeader(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        NAME_FIELD_NUMBER: builtins.int
        FORMAT_FIELD_NUMBER: builtins.int
        name: typing.Text = ...
        """The name of the reset header.

        .. note::

          If the header appears multiple times only the first value is used.
        """

        format: global___RetryPolicy.ResetHeaderFormat.V = ...
        """The format of the reset header."""

        def __init__(self,
            *,
            name : typing.Text = ...,
            format : global___RetryPolicy.ResetHeaderFormat.V = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"format",b"format",u"name",b"name"]) -> None: ...

    class RateLimitedRetryBackOff(google.protobuf.message.Message):
        """A retry back-off strategy that applies when the upstream server rate limits
        the request.

        Given this configuration:

        .. code-block:: yaml

          rate_limited_retry_back_off:
            reset_headers:
            - name: Retry-After
              format: SECONDS
            - name: X-RateLimit-Reset
              format: UNIX_TIMESTAMP
            max_interval: "300s"

        The following algorithm will apply:

         1. If the response contains the header ``Retry-After`` its value must be on
            the form ``120`` (an integer that represents the number of seconds to
            wait before retrying). If so, this value is used as the back-off interval.
         2. Otherwise, if the response contains the header ``X-RateLimit-Reset`` its
            value must be on the form ``1595320702`` (an integer that represents the
            point in time at which to retry, as a Unix timestamp in seconds). If so,
            the current time is subtracted from this value and the result is used as
            the back-off interval.
         3. Otherwise, Envoy will use the default
            :ref:`exponential back-off <envoy_v3_api_field_config.route.v3.RetryPolicy.retry_back_off>`
            strategy.

        No matter which format is used, if the resulting back-off interval exceeds
        ``max_interval`` it is discarded and the next header in ``reset_headers``
        is tried. If a request timeout is configured for the route it will further
        limit how long the request will be allowed to run.

        To prevent many clients retrying at the same point in time jitter is added
        to the back-off interval, so the resulting interval is decided by taking:
        ``random(interval, interval * 1.5)``.

        .. attention::

          Configuring ``rate_limited_retry_back_off`` will not by itself cause a request
          to be retried. You will still need to configure the right retry policy to match
          the responses from the upstream server.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        RESET_HEADERS_FIELD_NUMBER: builtins.int
        MAX_INTERVAL_FIELD_NUMBER: builtins.int
        @property
        def reset_headers(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RetryPolicy.ResetHeader]:
            """Specifies the reset headers (like ``Retry-After`` or ``X-RateLimit-Reset``)
            to match against the response. Headers are tried in order, and matched case
            insensitive. The first header to be parsed successfully is used. If no headers
            match the default exponential back-off is used instead.
            """
            pass
        @property
        def max_interval(self) -> google.protobuf.duration_pb2.Duration:
            """Specifies the maximum back off interval that Envoy will allow. If a reset
            header contains an interval longer than this then it will be discarded and
            the next header will be tried. Defaults to 300 seconds.
            """
            pass
        def __init__(self,
            *,
            reset_headers : typing.Optional[typing.Iterable[global___RetryPolicy.ResetHeader]] = ...,
            max_interval : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"max_interval",b"max_interval"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"max_interval",b"max_interval",u"reset_headers",b"reset_headers"]) -> None: ...

    RETRY_ON_FIELD_NUMBER: builtins.int
    NUM_RETRIES_FIELD_NUMBER: builtins.int
    PER_TRY_TIMEOUT_FIELD_NUMBER: builtins.int
    RETRY_PRIORITY_FIELD_NUMBER: builtins.int
    RETRY_HOST_PREDICATE_FIELD_NUMBER: builtins.int
    HOST_SELECTION_RETRY_MAX_ATTEMPTS_FIELD_NUMBER: builtins.int
    RETRIABLE_STATUS_CODES_FIELD_NUMBER: builtins.int
    RETRY_BACK_OFF_FIELD_NUMBER: builtins.int
    RATE_LIMITED_RETRY_BACK_OFF_FIELD_NUMBER: builtins.int
    RETRIABLE_HEADERS_FIELD_NUMBER: builtins.int
    RETRIABLE_REQUEST_HEADERS_FIELD_NUMBER: builtins.int
    retry_on: typing.Text = ...
    """Specifies the conditions under which retry takes place. These are the same
    conditions documented for :ref:`config_http_filters_router_x-envoy-retry-on` and
    :ref:`config_http_filters_router_x-envoy-retry-grpc-on`.
    """

    @property
    def num_retries(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """Specifies the allowed number of retries. This parameter is optional and
        defaults to 1. These are the same conditions documented for
        :ref:`config_http_filters_router_x-envoy-max-retries`.
        """
        pass
    @property
    def per_try_timeout(self) -> google.protobuf.duration_pb2.Duration:
        """Specifies a non-zero upstream timeout per retry attempt. This parameter is optional. The
        same conditions documented for
        :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms` apply.

        .. note::

          If left unspecified, Envoy will use the global
          :ref:`route timeout <envoy_v3_api_field_config.route.v3.RouteAction.timeout>` for the request.
          Consequently, when using a :ref:`5xx <config_http_filters_router_x-envoy-retry-on>` based
          retry policy, a request that times out will not be retried as the total timeout budget
          would have been exhausted.
        """
        pass
    @property
    def retry_priority(self) -> global___RetryPolicy.RetryPriority:
        """Specifies an implementation of a RetryPriority which is used to determine the
        distribution of load across priorities used for retries. Refer to
        :ref:`retry plugin configuration <arch_overview_http_retry_plugins>` for more details.
        """
        pass
    @property
    def retry_host_predicate(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RetryPolicy.RetryHostPredicate]:
        """Specifies a collection of RetryHostPredicates that will be consulted when selecting a host
        for retries. If any of the predicates reject the host, host selection will be reattempted.
        Refer to :ref:`retry plugin configuration <arch_overview_http_retry_plugins>` for more
        details.
        """
        pass
    host_selection_retry_max_attempts: builtins.int = ...
    """The maximum number of times host selection will be reattempted before giving up, at which
    point the host that was last selected will be routed to. If unspecified, this will default to
    retrying once.
    """

    @property
    def retriable_status_codes(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """HTTP status codes that should trigger a retry in addition to those specified by retry_on."""
        pass
    @property
    def retry_back_off(self) -> global___RetryPolicy.RetryBackOff:
        """Specifies parameters that control exponential retry back off. This parameter is optional, in which case the
        default base interval is 25 milliseconds or, if set, the current value of the
        `upstream.base_retry_backoff_ms` runtime parameter. The default maximum interval is 10 times
        the base interval. The documentation for :ref:`config_http_filters_router_x-envoy-max-retries`
        describes Envoy's back-off algorithm.
        """
        pass
    @property
    def rate_limited_retry_back_off(self) -> global___RetryPolicy.RateLimitedRetryBackOff:
        """Specifies parameters that control a retry back-off strategy that is used
        when the request is rate limited by the upstream server. The server may
        return a response header like ``Retry-After`` or ``X-RateLimit-Reset`` to
        provide feedback to the client on how long to wait before retrying. If
        configured, this back-off strategy will be used instead of the
        default exponential back off strategy (configured using `retry_back_off`)
        whenever a response includes the matching headers.
        """
        pass
    @property
    def retriable_headers(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___HeaderMatcher]:
        """HTTP response headers that trigger a retry if present in the response. A retry will be
        triggered if any of the header matches match the upstream response headers.
        The field is only consulted if 'retriable-headers' retry policy is active.
        """
        pass
    @property
    def retriable_request_headers(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___HeaderMatcher]:
        """HTTP headers which must be present in the request for retries to be attempted."""
        pass
    def __init__(self,
        *,
        retry_on : typing.Text = ...,
        num_retries : typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        per_try_timeout : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        retry_priority : typing.Optional[global___RetryPolicy.RetryPriority] = ...,
        retry_host_predicate : typing.Optional[typing.Iterable[global___RetryPolicy.RetryHostPredicate]] = ...,
        host_selection_retry_max_attempts : builtins.int = ...,
        retriable_status_codes : typing.Optional[typing.Iterable[builtins.int]] = ...,
        retry_back_off : typing.Optional[global___RetryPolicy.RetryBackOff] = ...,
        rate_limited_retry_back_off : typing.Optional[global___RetryPolicy.RateLimitedRetryBackOff] = ...,
        retriable_headers : typing.Optional[typing.Iterable[global___HeaderMatcher]] = ...,
        retriable_request_headers : typing.Optional[typing.Iterable[global___HeaderMatcher]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"num_retries",b"num_retries",u"per_try_timeout",b"per_try_timeout",u"rate_limited_retry_back_off",b"rate_limited_retry_back_off",u"retry_back_off",b"retry_back_off",u"retry_priority",b"retry_priority"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"host_selection_retry_max_attempts",b"host_selection_retry_max_attempts",u"num_retries",b"num_retries",u"per_try_timeout",b"per_try_timeout",u"rate_limited_retry_back_off",b"rate_limited_retry_back_off",u"retriable_headers",b"retriable_headers",u"retriable_request_headers",b"retriable_request_headers",u"retriable_status_codes",b"retriable_status_codes",u"retry_back_off",b"retry_back_off",u"retry_host_predicate",b"retry_host_predicate",u"retry_on",b"retry_on",u"retry_priority",b"retry_priority"]) -> None: ...
global___RetryPolicy = RetryPolicy

class HedgePolicy(google.protobuf.message.Message):
    """HTTP request hedging :ref:`architecture overview <arch_overview_http_routing_hedging>`."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    INITIAL_REQUESTS_FIELD_NUMBER: builtins.int
    ADDITIONAL_REQUEST_CHANCE_FIELD_NUMBER: builtins.int
    HEDGE_ON_PER_TRY_TIMEOUT_FIELD_NUMBER: builtins.int
    @property
    def initial_requests(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """Specifies the number of initial requests that should be sent upstream.
        Must be at least 1.
        Defaults to 1.
        [#not-implemented-hide:]
        """
        pass
    @property
    def additional_request_chance(self) -> envoy.type.v3.percent_pb2.FractionalPercent:
        """Specifies a probability that an additional upstream request should be sent
        on top of what is specified by initial_requests.
        Defaults to 0.
        [#not-implemented-hide:]
        """
        pass
    hedge_on_per_try_timeout: builtins.bool = ...
    """Indicates that a hedged request should be sent when the per-try timeout is hit.
    This means that a retry will be issued without resetting the original request, leaving multiple upstream requests in flight.
    The first request to complete successfully will be the one returned to the caller.

    * At any time, a successful response (i.e. not triggering any of the retry-on conditions) would be returned to the client.
    * Before per-try timeout, an error response (per retry-on conditions) would be retried immediately or returned ot the client
      if there are no more retries left.
    * After per-try timeout, an error response would be discarded, as a retry in the form of a hedged request is already in progress.

    Note: For this to have effect, you must have a :ref:`RetryPolicy <envoy_v3_api_msg_config.route.v3.RetryPolicy>` that retries at least
    one error code and specifies a maximum number of retries.

    Defaults to false.
    """

    def __init__(self,
        *,
        initial_requests : typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        additional_request_chance : typing.Optional[envoy.type.v3.percent_pb2.FractionalPercent] = ...,
        hedge_on_per_try_timeout : builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"additional_request_chance",b"additional_request_chance",u"initial_requests",b"initial_requests"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"additional_request_chance",b"additional_request_chance",u"hedge_on_per_try_timeout",b"hedge_on_per_try_timeout",u"initial_requests",b"initial_requests"]) -> None: ...
global___HedgePolicy = HedgePolicy

class RedirectAction(google.protobuf.message.Message):
    """[#next-free-field: 10]"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class RedirectResponseCode(_RedirectResponseCode, metaclass=_RedirectResponseCodeEnumTypeWrapper):
        pass
    class _RedirectResponseCode:
        V = typing.NewType('V', builtins.int)
    class _RedirectResponseCodeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_RedirectResponseCode.V], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        MOVED_PERMANENTLY = RedirectAction.RedirectResponseCode.V(0)
        """Moved Permanently HTTP Status Code - 301."""

        FOUND = RedirectAction.RedirectResponseCode.V(1)
        """Found HTTP Status Code - 302."""

        SEE_OTHER = RedirectAction.RedirectResponseCode.V(2)
        """See Other HTTP Status Code - 303."""

        TEMPORARY_REDIRECT = RedirectAction.RedirectResponseCode.V(3)
        """Temporary Redirect HTTP Status Code - 307."""

        PERMANENT_REDIRECT = RedirectAction.RedirectResponseCode.V(4)
        """Permanent Redirect HTTP Status Code - 308."""


    MOVED_PERMANENTLY = RedirectAction.RedirectResponseCode.V(0)
    """Moved Permanently HTTP Status Code - 301."""

    FOUND = RedirectAction.RedirectResponseCode.V(1)
    """Found HTTP Status Code - 302."""

    SEE_OTHER = RedirectAction.RedirectResponseCode.V(2)
    """See Other HTTP Status Code - 303."""

    TEMPORARY_REDIRECT = RedirectAction.RedirectResponseCode.V(3)
    """Temporary Redirect HTTP Status Code - 307."""

    PERMANENT_REDIRECT = RedirectAction.RedirectResponseCode.V(4)
    """Permanent Redirect HTTP Status Code - 308."""


    HTTPS_REDIRECT_FIELD_NUMBER: builtins.int
    SCHEME_REDIRECT_FIELD_NUMBER: builtins.int
    HOST_REDIRECT_FIELD_NUMBER: builtins.int
    PORT_REDIRECT_FIELD_NUMBER: builtins.int
    PATH_REDIRECT_FIELD_NUMBER: builtins.int
    PREFIX_REWRITE_FIELD_NUMBER: builtins.int
    REGEX_REWRITE_FIELD_NUMBER: builtins.int
    RESPONSE_CODE_FIELD_NUMBER: builtins.int
    STRIP_QUERY_FIELD_NUMBER: builtins.int
    https_redirect: builtins.bool = ...
    """The scheme portion of the URL will be swapped with "https"."""

    scheme_redirect: typing.Text = ...
    """The scheme portion of the URL will be swapped with this value."""

    host_redirect: typing.Text = ...
    """The host portion of the URL will be swapped with this value."""

    port_redirect: builtins.int = ...
    """The port value of the URL will be swapped with this value."""

    path_redirect: typing.Text = ...
    """The path portion of the URL will be swapped with this value.
    Please note that query string in path_redirect will override the
    request's query string and will not be stripped.

    For example, let's say we have the following routes:

    - match: { path: "/old-path-1" }
      redirect: { path_redirect: "/new-path-1" }
    - match: { path: "/old-path-2" }
      redirect: { path_redirect: "/new-path-2", strip-query: "true" }
    - match: { path: "/old-path-3" }
      redirect: { path_redirect: "/new-path-3?foo=1", strip_query: "true" }

    1. if request uri is "/old-path-1?bar=1", users will be redirected to "/new-path-1?bar=1"
    2. if request uri is "/old-path-2?bar=1", users will be redirected to "/new-path-2"
    3. if request uri is "/old-path-3?bar=1", users will be redirected to "/new-path-3?foo=1"
    """

    prefix_rewrite: typing.Text = ...
    """Indicates that during redirection, the matched prefix (or path)
    should be swapped with this value. This option allows redirect URLs be dynamically created
    based on the request.

    .. attention::

      Pay attention to the use of trailing slashes as mentioned in
      :ref:`RouteAction's prefix_rewrite <envoy_v3_api_field_config.route.v3.RouteAction.prefix_rewrite>`.
    """

    @property
    def regex_rewrite(self) -> envoy.type.matcher.v3.regex_pb2.RegexMatchAndSubstitute:
        """Indicates that during redirect, portions of the path that match the
        pattern should be rewritten, even allowing the substitution of capture
        groups from the pattern into the new path as specified by the rewrite
        substitution string. This is useful to allow application paths to be
        rewritten in a way that is aware of segments with variable content like
        identifiers.

        Examples using Google's `RE2 <https://github.com/google/re2>`_ engine:

        * The path pattern ``^/service/([^/]+)(/.*)$`` paired with a substitution
          string of ``\2/instance/\1`` would transform ``/service/foo/v1/api``
          into ``/v1/api/instance/foo``.

        * The pattern ``one`` paired with a substitution string of ``two`` would
          transform ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/two/zzz``.

        * The pattern ``^(.*?)one(.*)$`` paired with a substitution string of
          ``\1two\2`` would replace only the first occurrence of ``one``,
          transforming path ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/one/zzz``.

        * The pattern ``(?i)/xxx/`` paired with a substitution string of ``/yyy/``
          would do a case-insensitive match and transform path ``/aaa/XxX/bbb`` to
          ``/aaa/yyy/bbb``.
        """
        pass
    response_code: global___RedirectAction.RedirectResponseCode.V = ...
    """The HTTP status code to use in the redirect response. The default response
    code is MOVED_PERMANENTLY (301).
    """

    strip_query: builtins.bool = ...
    """Indicates that during redirection, the query portion of the URL will
    be removed. Default value is false.
    """

    def __init__(self,
        *,
        https_redirect : builtins.bool = ...,
        scheme_redirect : typing.Text = ...,
        host_redirect : typing.Text = ...,
        port_redirect : builtins.int = ...,
        path_redirect : typing.Text = ...,
        prefix_rewrite : typing.Text = ...,
        regex_rewrite : typing.Optional[envoy.type.matcher.v3.regex_pb2.RegexMatchAndSubstitute] = ...,
        response_code : global___RedirectAction.RedirectResponseCode.V = ...,
        strip_query : builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"https_redirect",b"https_redirect",u"path_redirect",b"path_redirect",u"path_rewrite_specifier",b"path_rewrite_specifier",u"prefix_rewrite",b"prefix_rewrite",u"regex_rewrite",b"regex_rewrite",u"scheme_redirect",b"scheme_redirect",u"scheme_rewrite_specifier",b"scheme_rewrite_specifier"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"host_redirect",b"host_redirect",u"https_redirect",b"https_redirect",u"path_redirect",b"path_redirect",u"path_rewrite_specifier",b"path_rewrite_specifier",u"port_redirect",b"port_redirect",u"prefix_rewrite",b"prefix_rewrite",u"regex_rewrite",b"regex_rewrite",u"response_code",b"response_code",u"scheme_redirect",b"scheme_redirect",u"scheme_rewrite_specifier",b"scheme_rewrite_specifier",u"strip_query",b"strip_query"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"path_rewrite_specifier",b"path_rewrite_specifier"]) -> typing.Optional[typing_extensions.Literal["path_redirect","prefix_rewrite","regex_rewrite"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"scheme_rewrite_specifier",b"scheme_rewrite_specifier"]) -> typing.Optional[typing_extensions.Literal["https_redirect","scheme_redirect"]]: ...
global___RedirectAction = RedirectAction

class DirectResponseAction(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    STATUS_FIELD_NUMBER: builtins.int
    BODY_FIELD_NUMBER: builtins.int
    status: builtins.int = ...
    """Specifies the HTTP response status to be returned."""

    @property
    def body(self) -> envoy.config.core.v3.base_pb2.DataSource:
        """Specifies the content of the response body. If this setting is omitted,
        no body is included in the generated response.

        .. note::

          Headers can be specified using *response_headers_to_add* in the enclosing
          :ref:`envoy_v3_api_msg_config.route.v3.Route`, :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration` or
          :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost`.
        """
        pass
    def __init__(self,
        *,
        status : builtins.int = ...,
        body : typing.Optional[envoy.config.core.v3.base_pb2.DataSource] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"body",b"body"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"body",b"body",u"status",b"status"]) -> None: ...
global___DirectResponseAction = DirectResponseAction

class NonForwardingAction(google.protobuf.message.Message):
    """[#not-implemented-hide:]"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___NonForwardingAction = NonForwardingAction

class Decorator(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    OPERATION_FIELD_NUMBER: builtins.int
    PROPAGATE_FIELD_NUMBER: builtins.int
    operation: typing.Text = ...
    """The operation name associated with the request matched to this route. If tracing is
    enabled, this information will be used as the span name reported for this request.

    .. note::

      For ingress (inbound) requests, or egress (outbound) responses, this value may be overridden
      by the :ref:`x-envoy-decorator-operation
      <config_http_filters_router_x-envoy-decorator-operation>` header.
    """

    @property
    def propagate(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """Whether the decorated details should be propagated to the other party. The default is true."""
        pass
    def __init__(self,
        *,
        operation : typing.Text = ...,
        propagate : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"propagate",b"propagate"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"operation",b"operation",u"propagate",b"propagate"]) -> None: ...
global___Decorator = Decorator

class Tracing(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CLIENT_SAMPLING_FIELD_NUMBER: builtins.int
    RANDOM_SAMPLING_FIELD_NUMBER: builtins.int
    OVERALL_SAMPLING_FIELD_NUMBER: builtins.int
    CUSTOM_TAGS_FIELD_NUMBER: builtins.int
    @property
    def client_sampling(self) -> envoy.type.v3.percent_pb2.FractionalPercent:
        """Target percentage of requests managed by this HTTP connection manager that will be force
        traced if the :ref:`x-client-trace-id <config_http_conn_man_headers_x-client-trace-id>`
        header is set. This field is a direct analog for the runtime variable
        'tracing.client_sampling' in the :ref:`HTTP Connection Manager
        <config_http_conn_man_runtime>`.
        Default: 100%
        """
        pass
    @property
    def random_sampling(self) -> envoy.type.v3.percent_pb2.FractionalPercent:
        """Target percentage of requests managed by this HTTP connection manager that will be randomly
        selected for trace generation, if not requested by the client or not forced. This field is
        a direct analog for the runtime variable 'tracing.random_sampling' in the
        :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
        Default: 100%
        """
        pass
    @property
    def overall_sampling(self) -> envoy.type.v3.percent_pb2.FractionalPercent:
        """Target percentage of requests managed by this HTTP connection manager that will be traced
        after all other sampling checks have been applied (client-directed, force tracing, random
        sampling). This field functions as an upper limit on the total configured sampling rate. For
        instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
        of client requests with the appropriate headers to be force traced. This field is a direct
        analog for the runtime variable 'tracing.global_enabled' in the
        :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
        Default: 100%
        """
        pass
    @property
    def custom_tags(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[envoy.type.tracing.v3.custom_tag_pb2.CustomTag]:
        """A list of custom tags with unique tag name to create tags for the active span.
        It will take effect after merging with the :ref:`corresponding configuration
        <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.custom_tags>`
        configured in the HTTP connection manager. If two tags with the same name are configured
        each in the HTTP connection manager and the route level, the one configured here takes
        priority.
        """
        pass
    def __init__(self,
        *,
        client_sampling : typing.Optional[envoy.type.v3.percent_pb2.FractionalPercent] = ...,
        random_sampling : typing.Optional[envoy.type.v3.percent_pb2.FractionalPercent] = ...,
        overall_sampling : typing.Optional[envoy.type.v3.percent_pb2.FractionalPercent] = ...,
        custom_tags : typing.Optional[typing.Iterable[envoy.type.tracing.v3.custom_tag_pb2.CustomTag]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"client_sampling",b"client_sampling",u"overall_sampling",b"overall_sampling",u"random_sampling",b"random_sampling"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"client_sampling",b"client_sampling",u"custom_tags",b"custom_tags",u"overall_sampling",b"overall_sampling",u"random_sampling",b"random_sampling"]) -> None: ...
global___Tracing = Tracing

class VirtualCluster(google.protobuf.message.Message):
    """A virtual cluster is a way of specifying a regex matching rule against
    certain important endpoints such that statistics are generated explicitly for
    the matched requests. The reason this is useful is that when doing
    prefix/path matching Envoy does not always know what the application
    considers to be an endpoint. Thus, itâ€™s impossible for Envoy to generically
    emit per endpoint statistics. However, often systems have highly critical
    endpoints that they wish to get â€œperfectâ€ statistics on. Virtual cluster
    statistics are perfect in the sense that they are emitted on the downstream
    side such that they include network level failures.

    Documentation for :ref:`virtual cluster statistics <config_http_filters_router_vcluster_stats>`.

    .. note::

       Virtual clusters are a useful tool, but we do not recommend setting up a virtual cluster for
       every application endpoint. This is both not easily maintainable and as well the matching and
       statistics output are not free.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    HEADERS_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    @property
    def headers(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___HeaderMatcher]:
        """Specifies a list of header matchers to use for matching requests. Each specified header must
        match. The pseudo-headers `:path` and `:method` can be used to match the request path and
        method, respectively.
        """
        pass
    name: typing.Text = ...
    """Specifies the name of the virtual cluster. The virtual cluster name as well
    as the virtual host name are used when emitting statistics. The statistics are emitted by the
    router filter and are documented :ref:`here <config_http_filters_router_stats>`.
    """

    def __init__(self,
        *,
        headers : typing.Optional[typing.Iterable[global___HeaderMatcher]] = ...,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"headers",b"headers",u"name",b"name"]) -> None: ...
global___VirtualCluster = VirtualCluster

class RateLimit(google.protobuf.message.Message):
    """Global rate limiting :ref:`architecture overview <arch_overview_global_rate_limit>`.
    Also applies to Local rate limiting :ref:`using descriptors <config_http_filters_local_rate_limit_descriptors>`.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Action(google.protobuf.message.Message):
        """[#next-free-field: 10]"""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class SourceCluster(google.protobuf.message.Message):
            """The following descriptor entry is appended to the descriptor:

            .. code-block:: cpp

              ("source_cluster", "<local service cluster>")

            <local service cluster> is derived from the :option:`--service-cluster` option.
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            def __init__(self,
                ) -> None: ...

        class DestinationCluster(google.protobuf.message.Message):
            """The following descriptor entry is appended to the descriptor:

            .. code-block:: cpp

              ("destination_cluster", "<routed target cluster>")

            Once a request matches against a route table rule, a routed cluster is determined by one of
            the following :ref:`route table configuration <envoy_v3_api_msg_config.route.v3.RouteConfiguration>`
            settings:

            * :ref:`cluster <envoy_v3_api_field_config.route.v3.RouteAction.cluster>` indicates the upstream cluster
              to route to.
            * :ref:`weighted_clusters <envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>`
              chooses a cluster randomly from a set of clusters with attributed weight.
            * :ref:`cluster_header <envoy_v3_api_field_config.route.v3.RouteAction.cluster_header>` indicates which
              header in the request contains the target cluster.
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            def __init__(self,
                ) -> None: ...

        class RequestHeaders(google.protobuf.message.Message):
            """The following descriptor entry is appended when a header contains a key that matches the
            *header_name*:

            .. code-block:: cpp

              ("<descriptor_key>", "<header_value_queried_from_header>")
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            HEADER_NAME_FIELD_NUMBER: builtins.int
            DESCRIPTOR_KEY_FIELD_NUMBER: builtins.int
            SKIP_IF_ABSENT_FIELD_NUMBER: builtins.int
            header_name: typing.Text = ...
            """The header name to be queried from the request headers. The headerâ€™s
            value is used to populate the value of the descriptor entry for the
            descriptor_key.
            """

            descriptor_key: typing.Text = ...
            """The key to use in the descriptor entry."""

            skip_if_absent: builtins.bool = ...
            """If set to true, Envoy skips the descriptor while calling rate limiting service
            when header is not present in the request. By default it skips calling the
            rate limiting service if this header is not present in the request.
            """

            def __init__(self,
                *,
                header_name : typing.Text = ...,
                descriptor_key : typing.Text = ...,
                skip_if_absent : builtins.bool = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal[u"descriptor_key",b"descriptor_key",u"header_name",b"header_name",u"skip_if_absent",b"skip_if_absent"]) -> None: ...

        class RemoteAddress(google.protobuf.message.Message):
            """The following descriptor entry is appended to the descriptor and is populated using the
            trusted address from :ref:`x-forwarded-for <config_http_conn_man_headers_x-forwarded-for>`:

            .. code-block:: cpp

              ("remote_address", "<trusted address from x-forwarded-for>")
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            def __init__(self,
                ) -> None: ...

        class GenericKey(google.protobuf.message.Message):
            """The following descriptor entry is appended to the descriptor:

            .. code-block:: cpp

              ("generic_key", "<descriptor_value>")
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            DESCRIPTOR_VALUE_FIELD_NUMBER: builtins.int
            DESCRIPTOR_KEY_FIELD_NUMBER: builtins.int
            descriptor_value: typing.Text = ...
            """The value to use in the descriptor entry."""

            descriptor_key: typing.Text = ...
            """An optional key to use in the descriptor entry. If not set it defaults
            to 'generic_key' as the descriptor key.
            """

            def __init__(self,
                *,
                descriptor_value : typing.Text = ...,
                descriptor_key : typing.Text = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal[u"descriptor_key",b"descriptor_key",u"descriptor_value",b"descriptor_value"]) -> None: ...

        class HeaderValueMatch(google.protobuf.message.Message):
            """The following descriptor entry is appended to the descriptor:

            .. code-block:: cpp

              ("header_match", "<descriptor_value>")
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            DESCRIPTOR_VALUE_FIELD_NUMBER: builtins.int
            EXPECT_MATCH_FIELD_NUMBER: builtins.int
            HEADERS_FIELD_NUMBER: builtins.int
            descriptor_value: typing.Text = ...
            """The value to use in the descriptor entry."""

            @property
            def expect_match(self) -> google.protobuf.wrappers_pb2.BoolValue:
                """If set to true, the action will append a descriptor entry when the
                request matches the headers. If set to false, the action will append a
                descriptor entry when the request does not match the headers. The
                default value is true.
                """
                pass
            @property
            def headers(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___HeaderMatcher]:
                """Specifies a set of headers that the rate limit action should match
                on. The action will check the requestâ€™s headers against all the
                specified headers in the config. A match will happen if all the
                headers in the config are present in the request with the same values
                (or based on presence if the value field is not in the config).
                """
                pass
            def __init__(self,
                *,
                descriptor_value : typing.Text = ...,
                expect_match : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
                headers : typing.Optional[typing.Iterable[global___HeaderMatcher]] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal[u"expect_match",b"expect_match"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal[u"descriptor_value",b"descriptor_value",u"expect_match",b"expect_match",u"headers",b"headers"]) -> None: ...

        class DynamicMetaData(google.protobuf.message.Message):
            """The following descriptor entry is appended when the
            :ref:`dynamic metadata <well_known_dynamic_metadata>` contains a key value:

            .. code-block:: cpp

              ("<descriptor_key>", "<value_queried_from_dynamic_metadata>")

            .. attention::
              This action has been deprecated in favor of the :ref:`metadata <envoy_v3_api_msg_config.route.v3.RateLimit.Action.MetaData>` action
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            DESCRIPTOR_KEY_FIELD_NUMBER: builtins.int
            METADATA_KEY_FIELD_NUMBER: builtins.int
            DEFAULT_VALUE_FIELD_NUMBER: builtins.int
            descriptor_key: typing.Text = ...
            """The key to use in the descriptor entry."""

            @property
            def metadata_key(self) -> envoy.type.metadata.v3.metadata_pb2.MetadataKey:
                """Metadata struct that defines the key and path to retrieve the string value. A match will
                only happen if the value in the dynamic metadata is of type string.
                """
                pass
            default_value: typing.Text = ...
            """An optional value to use if *metadata_key* is empty. If not set and
            no value is present under the metadata_key then no descriptor is generated.
            """

            def __init__(self,
                *,
                descriptor_key : typing.Text = ...,
                metadata_key : typing.Optional[envoy.type.metadata.v3.metadata_pb2.MetadataKey] = ...,
                default_value : typing.Text = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal[u"metadata_key",b"metadata_key"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal[u"default_value",b"default_value",u"descriptor_key",b"descriptor_key",u"metadata_key",b"metadata_key"]) -> None: ...

        class MetaData(google.protobuf.message.Message):
            """The following descriptor entry is appended when the metadata contains a key value:

            .. code-block:: cpp

              ("<descriptor_key>", "<value_queried_from_metadata>")
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            class Source(_Source, metaclass=_SourceEnumTypeWrapper):
                pass
            class _Source:
                V = typing.NewType('V', builtins.int)
            class _SourceEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Source.V], builtins.type):
                DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
                DYNAMIC = RateLimit.Action.MetaData.Source.V(0)
                """Query :ref:`dynamic metadata <well_known_dynamic_metadata>`"""

                ROUTE_ENTRY = RateLimit.Action.MetaData.Source.V(1)
                """Query :ref:`route entry metadata <envoy_v3_api_field_config.route.v3.Route.metadata>`"""


            DYNAMIC = RateLimit.Action.MetaData.Source.V(0)
            """Query :ref:`dynamic metadata <well_known_dynamic_metadata>`"""

            ROUTE_ENTRY = RateLimit.Action.MetaData.Source.V(1)
            """Query :ref:`route entry metadata <envoy_v3_api_field_config.route.v3.Route.metadata>`"""


            DESCRIPTOR_KEY_FIELD_NUMBER: builtins.int
            METADATA_KEY_FIELD_NUMBER: builtins.int
            DEFAULT_VALUE_FIELD_NUMBER: builtins.int
            SOURCE_FIELD_NUMBER: builtins.int
            descriptor_key: typing.Text = ...
            """The key to use in the descriptor entry."""

            @property
            def metadata_key(self) -> envoy.type.metadata.v3.metadata_pb2.MetadataKey:
                """Metadata struct that defines the key and path to retrieve the string value. A match will
                only happen if the value in the metadata is of type string.
                """
                pass
            default_value: typing.Text = ...
            """An optional value to use if *metadata_key* is empty. If not set and
            no value is present under the metadata_key then no descriptor is generated.
            """

            source: global___RateLimit.Action.MetaData.Source.V = ...
            """Source of metadata"""

            def __init__(self,
                *,
                descriptor_key : typing.Text = ...,
                metadata_key : typing.Optional[envoy.type.metadata.v3.metadata_pb2.MetadataKey] = ...,
                default_value : typing.Text = ...,
                source : global___RateLimit.Action.MetaData.Source.V = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal[u"metadata_key",b"metadata_key"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal[u"default_value",b"default_value",u"descriptor_key",b"descriptor_key",u"metadata_key",b"metadata_key",u"source",b"source"]) -> None: ...

        SOURCE_CLUSTER_FIELD_NUMBER: builtins.int
        DESTINATION_CLUSTER_FIELD_NUMBER: builtins.int
        REQUEST_HEADERS_FIELD_NUMBER: builtins.int
        REMOTE_ADDRESS_FIELD_NUMBER: builtins.int
        GENERIC_KEY_FIELD_NUMBER: builtins.int
        HEADER_VALUE_MATCH_FIELD_NUMBER: builtins.int
        DYNAMIC_METADATA_FIELD_NUMBER: builtins.int
        METADATA_FIELD_NUMBER: builtins.int
        EXTENSION_FIELD_NUMBER: builtins.int
        @property
        def source_cluster(self) -> global___RateLimit.Action.SourceCluster:
            """Rate limit on source cluster."""
            pass
        @property
        def destination_cluster(self) -> global___RateLimit.Action.DestinationCluster:
            """Rate limit on destination cluster."""
            pass
        @property
        def request_headers(self) -> global___RateLimit.Action.RequestHeaders:
            """Rate limit on request headers."""
            pass
        @property
        def remote_address(self) -> global___RateLimit.Action.RemoteAddress:
            """Rate limit on remote address."""
            pass
        @property
        def generic_key(self) -> global___RateLimit.Action.GenericKey:
            """Rate limit on a generic key."""
            pass
        @property
        def header_value_match(self) -> global___RateLimit.Action.HeaderValueMatch:
            """Rate limit on the existence of request headers."""
            pass
        @property
        def dynamic_metadata(self) -> global___RateLimit.Action.DynamicMetaData:
            """Rate limit on dynamic metadata.

            .. attention::
              This field has been deprecated in favor of the :ref:`metadata <envoy_v3_api_field_config.route.v3.RateLimit.Action.metadata>` field
            """
            pass
        @property
        def metadata(self) -> global___RateLimit.Action.MetaData:
            """Rate limit on metadata."""
            pass
        @property
        def extension(self) -> envoy.config.core.v3.extension_pb2.TypedExtensionConfig:
            """Rate limit descriptor extension. See the rate limit descriptor extensions documentation.
            [#extension-category: envoy.rate_limit_descriptors]
            """
            pass
        def __init__(self,
            *,
            source_cluster : typing.Optional[global___RateLimit.Action.SourceCluster] = ...,
            destination_cluster : typing.Optional[global___RateLimit.Action.DestinationCluster] = ...,
            request_headers : typing.Optional[global___RateLimit.Action.RequestHeaders] = ...,
            remote_address : typing.Optional[global___RateLimit.Action.RemoteAddress] = ...,
            generic_key : typing.Optional[global___RateLimit.Action.GenericKey] = ...,
            header_value_match : typing.Optional[global___RateLimit.Action.HeaderValueMatch] = ...,
            dynamic_metadata : typing.Optional[global___RateLimit.Action.DynamicMetaData] = ...,
            metadata : typing.Optional[global___RateLimit.Action.MetaData] = ...,
            extension : typing.Optional[envoy.config.core.v3.extension_pb2.TypedExtensionConfig] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"action_specifier",b"action_specifier",u"destination_cluster",b"destination_cluster",u"dynamic_metadata",b"dynamic_metadata",u"extension",b"extension",u"generic_key",b"generic_key",u"header_value_match",b"header_value_match",u"metadata",b"metadata",u"remote_address",b"remote_address",u"request_headers",b"request_headers",u"source_cluster",b"source_cluster"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"action_specifier",b"action_specifier",u"destination_cluster",b"destination_cluster",u"dynamic_metadata",b"dynamic_metadata",u"extension",b"extension",u"generic_key",b"generic_key",u"header_value_match",b"header_value_match",u"metadata",b"metadata",u"remote_address",b"remote_address",u"request_headers",b"request_headers",u"source_cluster",b"source_cluster"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal[u"action_specifier",b"action_specifier"]) -> typing.Optional[typing_extensions.Literal["source_cluster","destination_cluster","request_headers","remote_address","generic_key","header_value_match","dynamic_metadata","metadata","extension"]]: ...

    class Override(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class DynamicMetadata(google.protobuf.message.Message):
            """Fetches the override from the dynamic metadata."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            METADATA_KEY_FIELD_NUMBER: builtins.int
            @property
            def metadata_key(self) -> envoy.type.metadata.v3.metadata_pb2.MetadataKey:
                """Metadata struct that defines the key and path to retrieve the struct value.
                The value must be a struct containing an integer "requests_per_unit" property
                and a "unit" property with a value parseable to :ref:`RateLimitUnit
                enum <envoy_v3_api_enum_type.v3.RateLimitUnit>`
                """
                pass
            def __init__(self,
                *,
                metadata_key : typing.Optional[envoy.type.metadata.v3.metadata_pb2.MetadataKey] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal[u"metadata_key",b"metadata_key"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal[u"metadata_key",b"metadata_key"]) -> None: ...

        DYNAMIC_METADATA_FIELD_NUMBER: builtins.int
        @property
        def dynamic_metadata(self) -> global___RateLimit.Override.DynamicMetadata:
            """Limit override from dynamic metadata."""
            pass
        def __init__(self,
            *,
            dynamic_metadata : typing.Optional[global___RateLimit.Override.DynamicMetadata] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"dynamic_metadata",b"dynamic_metadata",u"override_specifier",b"override_specifier"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"dynamic_metadata",b"dynamic_metadata",u"override_specifier",b"override_specifier"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal[u"override_specifier",b"override_specifier"]) -> typing.Optional[typing_extensions.Literal["dynamic_metadata"]]: ...

    STAGE_FIELD_NUMBER: builtins.int
    DISABLE_KEY_FIELD_NUMBER: builtins.int
    ACTIONS_FIELD_NUMBER: builtins.int
    LIMIT_FIELD_NUMBER: builtins.int
    @property
    def stage(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """Refers to the stage set in the filter. The rate limit configuration only
        applies to filters with the same stage number. The default stage number is
        0.

        .. note::

          The filter supports a range of 0 - 10 inclusively for stage numbers.
        """
        pass
    disable_key: typing.Text = ...
    """The key to be set in runtime to disable this rate limit configuration."""

    @property
    def actions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RateLimit.Action]:
        """A list of actions that are to be applied for this rate limit configuration.
        Order matters as the actions are processed sequentially and the descriptor
        is composed by appending descriptor entries in that sequence. If an action
        cannot append a descriptor entry, no descriptor is generated for the
        configuration. See :ref:`composing actions
        <config_http_filters_rate_limit_composing_actions>` for additional documentation.
        """
        pass
    @property
    def limit(self) -> global___RateLimit.Override:
        """An optional limit override to be appended to the descriptor produced by this
        rate limit configuration. If the override value is invalid or cannot be resolved
        from metadata, no override is provided. See :ref:`rate limit override
        <config_http_filters_rate_limit_rate_limit_override>` for more information.
        """
        pass
    def __init__(self,
        *,
        stage : typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        disable_key : typing.Text = ...,
        actions : typing.Optional[typing.Iterable[global___RateLimit.Action]] = ...,
        limit : typing.Optional[global___RateLimit.Override] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"limit",b"limit",u"stage",b"stage"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"actions",b"actions",u"disable_key",b"disable_key",u"limit",b"limit",u"stage",b"stage"]) -> None: ...
global___RateLimit = RateLimit

class HeaderMatcher(google.protobuf.message.Message):
    """.. attention::

      Internally, Envoy always uses the HTTP/2 *:authority* header to represent the HTTP/1 *Host*
      header. Thus, if attempting to match on *Host*, match on *:authority* instead.

    .. attention::

      To route on HTTP method, use the special HTTP/2 *:method* header. This works for both
      HTTP/1 and HTTP/2 as Envoy normalizes headers. E.g.,

      .. code-block:: json

        {
          "name": ":method",
          "exact_match": "POST"
        }

    .. attention::
      In the absence of any header match specifier, match will default to :ref:`present_match
      <envoy_v3_api_field_config.route.v3.HeaderMatcher.present_match>`. i.e, a request that has the :ref:`name
      <envoy_v3_api_field_config.route.v3.HeaderMatcher.name>` header will match, regardless of the header's
      value.

     [#next-major-version: HeaderMatcher should be refactored to use StringMatcher.]
    [#next-free-field: 14]
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    EXACT_MATCH_FIELD_NUMBER: builtins.int
    SAFE_REGEX_MATCH_FIELD_NUMBER: builtins.int
    RANGE_MATCH_FIELD_NUMBER: builtins.int
    PRESENT_MATCH_FIELD_NUMBER: builtins.int
    PREFIX_MATCH_FIELD_NUMBER: builtins.int
    SUFFIX_MATCH_FIELD_NUMBER: builtins.int
    CONTAINS_MATCH_FIELD_NUMBER: builtins.int
    STRING_MATCH_FIELD_NUMBER: builtins.int
    INVERT_MATCH_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Specifies the name of the header in the request."""

    exact_match: typing.Text = ...
    """If specified, header match will be performed based on the value of the header.
    This field is deprecated. Please use :ref:`string_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.string_match>`.
    """

    @property
    def safe_regex_match(self) -> envoy.type.matcher.v3.regex_pb2.RegexMatcher:
        """If specified, this regex string is a regular expression rule which implies the entire request
        header value must match the regex. The rule will not match if only a subsequence of the
        request header value matches the regex.
        This field is deprecated. Please use :ref:`string_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.string_match>`.
        """
        pass
    @property
    def range_match(self) -> envoy.type.v3.range_pb2.Int64Range:
        """If specified, header match will be performed based on range.
        The rule will match if the request header value is within this range.
        The entire request header value must represent an integer in base 10 notation: consisting of
        an optional plus or minus sign followed by a sequence of digits. The rule will not match if
        the header value does not represent an integer. Match will fail for empty values, floating
        point numbers or if only a subsequence of the header value is an integer.

        Examples:

        * For range [-10,0), route will match for header value -1, but not for 0, "somestring", 10.9,
          "-1somestring"
        """
        pass
    present_match: builtins.bool = ...
    """If specified as true, header match will be performed based on whether the header is in the
    request. If specified as false, header match will be performed based on whether the header is absent.
    """

    prefix_match: typing.Text = ...
    """If specified, header match will be performed based on the prefix of the header value.
    Note: empty prefix is not allowed, please use present_match instead.
    This field is deprecated. Please use :ref:`string_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.string_match>`.

    Examples:

    * The prefix *abcd* matches the value *abcdxyz*, but not for *abcxyz*.
    """

    suffix_match: typing.Text = ...
    """If specified, header match will be performed based on the suffix of the header value.
    Note: empty suffix is not allowed, please use present_match instead.
    This field is deprecated. Please use :ref:`string_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.string_match>`.

    Examples:

    * The suffix *abcd* matches the value *xyzabcd*, but not for *xyzbcd*.
    """

    contains_match: typing.Text = ...
    """If specified, header match will be performed based on whether the header value contains
    the given value or not.
    Note: empty contains match is not allowed, please use present_match instead.
    This field is deprecated. Please use :ref:`string_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.string_match>`.

    Examples:

    * The value *abcd* matches the value *xyzabcdpqr*, but not for *xyzbcdpqr*.
    """

    @property
    def string_match(self) -> envoy.type.matcher.v3.string_pb2.StringMatcher:
        """If specified, header match will be performed based on the string match of the header value."""
        pass
    invert_match: builtins.bool = ...
    """If specified, the match result will be inverted before checking. Defaults to false.

    Examples:

    * The regex ``\d{3}`` does not match the value *1234*, so it will match when inverted.
    * The range [-10,0) will match the value -1, so it will not match when inverted.
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        exact_match : typing.Text = ...,
        safe_regex_match : typing.Optional[envoy.type.matcher.v3.regex_pb2.RegexMatcher] = ...,
        range_match : typing.Optional[envoy.type.v3.range_pb2.Int64Range] = ...,
        present_match : builtins.bool = ...,
        prefix_match : typing.Text = ...,
        suffix_match : typing.Text = ...,
        contains_match : typing.Text = ...,
        string_match : typing.Optional[envoy.type.matcher.v3.string_pb2.StringMatcher] = ...,
        invert_match : builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"contains_match",b"contains_match",u"exact_match",b"exact_match",u"header_match_specifier",b"header_match_specifier",u"prefix_match",b"prefix_match",u"present_match",b"present_match",u"range_match",b"range_match",u"safe_regex_match",b"safe_regex_match",u"string_match",b"string_match",u"suffix_match",b"suffix_match"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"contains_match",b"contains_match",u"exact_match",b"exact_match",u"header_match_specifier",b"header_match_specifier",u"invert_match",b"invert_match",u"name",b"name",u"prefix_match",b"prefix_match",u"present_match",b"present_match",u"range_match",b"range_match",u"safe_regex_match",b"safe_regex_match",u"string_match",b"string_match",u"suffix_match",b"suffix_match"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"header_match_specifier",b"header_match_specifier"]) -> typing.Optional[typing_extensions.Literal["exact_match","safe_regex_match","range_match","present_match","prefix_match","suffix_match","contains_match","string_match"]]: ...
global___HeaderMatcher = HeaderMatcher

class QueryParameterMatcher(google.protobuf.message.Message):
    """Query parameter matching treats the query string of a request's :path header
    as an ampersand-separated list of keys and/or key=value elements.
    [#next-free-field: 7]
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    STRING_MATCH_FIELD_NUMBER: builtins.int
    PRESENT_MATCH_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Specifies the name of a key that must be present in the requested
    *path*'s query string.
    """

    @property
    def string_match(self) -> envoy.type.matcher.v3.string_pb2.StringMatcher:
        """Specifies whether a query parameter value should match against a string."""
        pass
    present_match: builtins.bool = ...
    """Specifies whether a query parameter should be present."""

    def __init__(self,
        *,
        name : typing.Text = ...,
        string_match : typing.Optional[envoy.type.matcher.v3.string_pb2.StringMatcher] = ...,
        present_match : builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"present_match",b"present_match",u"query_parameter_match_specifier",b"query_parameter_match_specifier",u"string_match",b"string_match"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"name",b"name",u"present_match",b"present_match",u"query_parameter_match_specifier",b"query_parameter_match_specifier",u"string_match",b"string_match"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"query_parameter_match_specifier",b"query_parameter_match_specifier"]) -> typing.Optional[typing_extensions.Literal["string_match","present_match"]]: ...
global___QueryParameterMatcher = QueryParameterMatcher

class InternalRedirectPolicy(google.protobuf.message.Message):
    """HTTP Internal Redirect :ref:`architecture overview <arch_overview_internal_redirects>`."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    MAX_INTERNAL_REDIRECTS_FIELD_NUMBER: builtins.int
    REDIRECT_RESPONSE_CODES_FIELD_NUMBER: builtins.int
    PREDICATES_FIELD_NUMBER: builtins.int
    ALLOW_CROSS_SCHEME_REDIRECT_FIELD_NUMBER: builtins.int
    @property
    def max_internal_redirects(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """An internal redirect is not handled, unless the number of previous internal redirects that a
        downstream request has encountered is lower than this value.
        In the case where a downstream request is bounced among multiple routes by internal redirect,
        the first route that hits this threshold, or does not set :ref:`internal_redirect_policy
        <envoy_v3_api_field_config.route.v3.RouteAction.internal_redirect_policy>`
        will pass the redirect back to downstream.

        If not specified, at most one redirect will be followed.
        """
        pass
    @property
    def redirect_response_codes(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Defines what upstream response codes are allowed to trigger internal redirect. If unspecified,
        only 302 will be treated as internal redirect.
        Only 301, 302, 303, 307 and 308 are valid values. Any other codes will be ignored.
        """
        pass
    @property
    def predicates(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[envoy.config.core.v3.extension_pb2.TypedExtensionConfig]:
        """Specifies a list of predicates that are queried when an upstream response is deemed
        to trigger an internal redirect by all other criteria. Any predicate in the list can reject
        the redirect, causing the response to be proxied to downstream.
        [#extension-category: envoy.internal_redirect_predicates]
        """
        pass
    allow_cross_scheme_redirect: builtins.bool = ...
    """Allow internal redirect to follow a target URI with a different scheme than the value of
    x-forwarded-proto. The default is false.
    """

    def __init__(self,
        *,
        max_internal_redirects : typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        redirect_response_codes : typing.Optional[typing.Iterable[builtins.int]] = ...,
        predicates : typing.Optional[typing.Iterable[envoy.config.core.v3.extension_pb2.TypedExtensionConfig]] = ...,
        allow_cross_scheme_redirect : builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"max_internal_redirects",b"max_internal_redirects"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"allow_cross_scheme_redirect",b"allow_cross_scheme_redirect",u"max_internal_redirects",b"max_internal_redirects",u"predicates",b"predicates",u"redirect_response_codes",b"redirect_response_codes"]) -> None: ...
global___InternalRedirectPolicy = InternalRedirectPolicy

class FilterConfig(google.protobuf.message.Message):
    """A simple wrapper for an HTTP filter config. This is intended to be used as a wrapper for the
    map value in
    :ref:`VirtualHost.typed_per_filter_config<envoy_v3_api_field_config.route.v3.VirtualHost.typed_per_filter_config>`,
    :ref:`Route.typed_per_filter_config<envoy_v3_api_field_config.route.v3.Route.typed_per_filter_config>`,
    or :ref:`WeightedCluster.ClusterWeight.typed_per_filter_config<envoy_v3_api_field_config.route.v3.WeightedCluster.ClusterWeight.typed_per_filter_config>`
    to add additional flags to the filter.
    [#not-implemented-hide:]
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CONFIG_FIELD_NUMBER: builtins.int
    IS_OPTIONAL_FIELD_NUMBER: builtins.int
    @property
    def config(self) -> google.protobuf.any_pb2.Any:
        """The filter config."""
        pass
    is_optional: builtins.bool = ...
    """If true, the filter is optional, meaning that if the client does
    not support the specified filter, it may ignore the map entry rather
    than rejecting the config.
    """

    def __init__(self,
        *,
        config : typing.Optional[google.protobuf.any_pb2.Any] = ...,
        is_optional : builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"config",b"config"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"config",b"config",u"is_optional",b"is_optional"]) -> None: ...
global___FilterConfig = FilterConfig
